        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Bidi class / intl Library / Dart API Reference</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        <link rel="stylesheet" type="text/css"
            href="../apidoc-styles.css" />
        
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(["_setAccount", "UA-26406144-9"]);
          _gaq.push(["_trackPageview"]);

          (function() {
            var ga = document.createElement("script");
            ga.type = "text/javascript"; ga.async = true;
            ga.src = ("https:" == document.location.protocol ?
              "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(ga, s);
          })();
        </script>
        
        </head>
        <body data-library="intl" data-type="Bidi">
        <div class="page">
        <div class="header">
          <a href="http://dartlang.org" ref="external"><div class="logo"></div></a>
          <a href="../index.html">Dart API Reference</a>
         &rsaquo; <a href="../intl.html">intl</a> &rsaquo; <a href="../intl/Bidi.html">Bidi</a>        <form action="http://www.dartlang.org/search.html" id="search-box">
          <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
          <input type="hidden" name="ie" value="UTF-8">
          <input type="hidden" name="hl" value="en">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </form>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../args.html">args</a></h2><h2><div class="icon-library"></div><a href="../dart_async.html">dart:async</a></h2><h2><div class="icon-library"></div><a href="../dart_chrome.html">dart:chrome</a></h2><h2><div class="icon-library"></div><a href="../dart_collection.html">dart:collection</a></h2><h2><div class="icon-library"></div><a href="../dart_core.html">dart:core</a></h2><h2><div class="icon-library"></div><a href="../dart_crypto.html">dart:crypto</a></h2><h2><div class="icon-library"></div><a href="../dart_html.html">dart:html</a></h2><h2><div class="icon-library"></div><a href="../dart_indexed_db.html">dart:indexed_db</a></h2><h2><div class="icon-library"></div><a href="../dart_io.html">dart:io</a></h2><h2><div class="icon-library"></div><a href="../dart_isolate.html">dart:isolate</a></h2><h2><div class="icon-library"></div><a href="../dart_json.html">dart:json</a></h2><h2><div class="icon-library"></div><a href="../dart_math.html">dart:math</a></h2><h2><div class="icon-library"></div><a href="../dart_mirrors.html">dart:mirrors</a></h2><h2><div class="icon-library"></div><a href="../dart_scalarlist.html">dart:scalarlist</a></h2><h2><div class="icon-library"></div><a href="../dart_svg.html">dart:svg</a></h2><h2><div class="icon-library"></div><a href="../dart_uri.html">dart:uri</a></h2><h2><div class="icon-library"></div><a href="../dart_utf.html">dart:utf</a></h2><h2><div class="icon-library"></div><a href="../dart_web_audio.html">dart:web_audio</a></h2><h2><div class="icon-library"></div><a href="../dart_web_sql.html">dart:web_sql</a></h2><h2><div class="icon-library"></div><a href="../fixnum.html">fixnum</a></h2><h2><div class="icon-library"></div><a href="../intl.html">intl</a></h2><ul class="icon">
<li><div class="icon-class"></div><strong>Bidi</strong></li>
<li><a href="../intl/BidiFormatter.html"><div class="icon-class"></div>BidiFormatter</a></li>
<li><a href="../intl/DateFormat.html"><div class="icon-class"></div>DateFormat</a></li>
<li><a href="../intl/Intl.html"><div class="icon-class"></div>Intl</a></li>
<li><a href="../intl/TextDirection.html"><div class="icon-class"></div>TextDirection</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../logging.html">logging</a></h2><h2><div class="icon-library"></div><a href="../matcher.html">matcher</a></h2><h2><div class="icon-library"></div><a href="../meta.html">meta</a></h2><h2><div class="icon-library"></div><a href="../mock.html">mock</a></h2><h2><div class="icon-library"></div><a href="../scheduled_test.html">scheduled_test</a></h2><h2><div class="icon-library"></div><a href="../serialization.html">serialization</a></h2><h2><div class="icon-library"></div><a href="../unittest.html">unittest</a></h2></div>
<div class="content">
        <h2><strong>Bidi</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>This provides utility methods for working with bidirectional text. All
of the methods are static, and are organized into a class primarily to
group them together for documentation and discoverability.</p>
<pre class="source">
class Bidi {

 /** Unicode "Left-To-Right Embedding" (LRE) character. */
 static const LRE = '\u202A';

 /** Unicode "Right-To-Left Embedding" (RLE) character. */
 static const RLE = '\u202B';

 /** Unicode "Pop Directional Formatting" (PDF) character. */
 static const PDF = '\u202C';

 /** Unicode "Left-To-Right Mark" (LRM) character. */
 static const LRM = '\u200E';

 /** Unicode "Right-To-Left Mark" (RLM) character. */
 static const RLM = '\u200F';

 /** Constant to define the threshold of RTL directionality. */
 static num _RTL_DETECTION_THRESHOLD = 0.40;

 /**
  * Practical patterns to identify strong LTR and RTL characters, respectively.
  * These patterns are not completely correct according to the Unicode
  * standard. They are simplified for performance and small code size.
  */
 static const String _LTR_CHARS =
     r'A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u0300-\u0590'
     r'\u0800-\u1FFF\u2C00-\uFB1C\uFDFE-\uFE6F\uFEFD-\uFFFF';
 static const String _RTL_CHARS = r'\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC';

 /**
  * Returns the input [text] with spaces instead of HTML tags or HTML escapes,
  * which is helpful for text directionality estimation.
  * Note: This function should not be used in other contexts.
  * It does not deal well with many things: comments, script,
  * elements, style elements, dir attribute,`&gt;` in quoted attribute values,
  * etc. But it does handle well enough the most common use cases.
  * Since the worst that can happen as a result of these shortcomings is that
  * the wrong directionality will be estimated, we have not invested in
  * improving this.
  */
 static String stripHtmlIfNeeded(String text) {
   // The regular expression is simplified for an HTML tag (opening or
   // closing) or an HTML escape. We might want to skip over such expressions
   // when estimating the text directionality.
   return text.replaceAll(new RegExp(r'&lt;[^&gt;]*&gt;|&amp;[^;]+;'), ' ');
 }

 /**
  * Determines if the first character in [text] with strong directionality is
  * LTR. If [isHtml] is true, the text is HTML or HTML-escaped.
  */
 static bool startsWithLtr(String text, [isHtml=false]) {
   return new RegExp('^[^$_RTL_CHARS]*[$_LTR_CHARS]').hasMatch(
       isHtml? stripHtmlIfNeeded(text) : text);
 }

 /**
  * Determines if the first character in [text] with strong directionality is
  * RTL. If [isHtml] is true, the text is HTML or HTML-escaped.
  */
 static bool startsWithRtl(String text, [isHtml=false]) {
   return new RegExp('^[^$_LTR_CHARS]*[$_RTL_CHARS]').hasMatch(
       isHtml? stripHtmlIfNeeded(text) : text);
 }

 /**
  * Determines if the exit directionality (ie, the last strongly-directional
  * character in [text] is LTR. If [isHtml] is true, the text is HTML or
  * HTML-escaped.
  */
 static bool endsWithLtr(String text, [isHtml=false]) {
   return new RegExp('[$_LTR_CHARS][^$_RTL_CHARS]*\$').hasMatch(
       isHtml? stripHtmlIfNeeded(text) : text);
 }

 /**
  * Determines if the exit directionality (ie, the last strongly-directional
  * character in [text] is RTL. If [isHtml] is true, the text is HTML or
  * HTML-escaped.
  */
 static bool endsWithRtl(String text, [isHtml=false]) {
   return new RegExp('[$_RTL_CHARS][^$_LTR_CHARS]*\$').hasMatch(
       isHtml? stripHtmlIfNeeded(text) : text);
 }

 /**
  * Determines if the given [text] has any LTR characters in it.
  * If [isHtml] is true, the text is HTML or HTML-escaped.
  */
 static bool hasAnyLtr(String text, [isHtml=false]) {
   return new RegExp(r'[' '$_LTR_CHARS' r']').hasMatch(
       isHtml? stripHtmlIfNeeded(text) : text);
 }

 /**
  * Determines if the given [text] has any RTL characters in it.
  * If [isHtml] is true, the text is HTML or HTML-escaped.
  */
 static bool hasAnyRtl(String text, [isHtml=false]) {
   return new RegExp(r'[' '$_RTL_CHARS' r']').hasMatch(
       isHtml? stripHtmlIfNeeded(text) : text);
 }

 /**
  * Check if a BCP 47 / III [languageString] indicates an RTL language.
  *
  * i.e. either:
  * - a language code explicitly specifying one of the right-to-left scripts,
  *   e.g. "az-Arab", or
  * - a language code specifying one of the languages normally written in a
  *   right-to-left script, e.g. "fa" (Farsi), except ones explicitly
  *   specifying Latin or Cyrillic script (which are the usual LTR
  *   alternatives).
  *
  * The list of right-to-left scripts appears in the 100-199 range in
  * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
  * Hebrew are by far the most widely used. We also recognize Thaana, N'Ko, and
  * Tifinagh, which also have significant modern usage. The rest (Syriac,
  * Samaritan, Mandaic, etc.) seem to have extremely limited or no modern usage
  * and are not recognized.
  * The languages usually written in a right-to-left script are taken as those
  * with Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in
  * http://www.iana.org/assignments/language-subtag-registry,
  * as well as Sindhi (sd) and Uyghur (ug).
  * The presence of other subtags of the language code, e.g. regions like EG
  * (Egypt), is ignored.
  */
 static bool isRtlLanguage(String languageString) {
   return new RegExp(r'^(ar|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_]'
       r'(Arab|Hebr|Thaa|Nkoo|Tfng))(?!.*[-_](Latn|Cyrl)($|-|_))'
       r'($|-|_)', caseSensitive: false).hasMatch(languageString);
 }

 /**
  * Enforce the [html] snippet in RTL directionality regardless of overall
  * context. If the html piece was enclosed by a tag, the direction will be
  * applied to existing tag, otherwise a span tag will be added as wrapper.
  * For this reason, if html snippet start with with tag, this tag must enclose
  * the whole piece. If the tag already has a direction specified, this new one
  * will override existing one in behavior (should work on Chrome, FF, and IE
  * since this was ported directly from the Closure version).
  */
 static String enforceRtlInHtml(String html) {
   return _enforceInHtmlHelper(html, 'rtl');
 }

 /**
  * Enforce RTL on both end of the given [text] using unicode BiDi formatting
  * characters RLE and PDF.
  */
 static String enforceRtlInText(String text) {
   return '$RLE$text$PDF';
 }

 /**
  * Enforce the [html] snippet in LTR directionality regardless of overall
  * context. If the html piece was enclosed by a tag, the direction will be
  * applied to existing tag, otherwise a span tag will be added as wrapper.
  * For this reason, if html snippet start with with tag, this tag must enclose
  * the whole piece. If the tag already has a direction specified, this new one
  * will override existing one in behavior (tested on FF and IE).
  */
 static String enforceLtrInHtml(String html) {
   return _enforceInHtmlHelper(html, 'ltr');
 }

 /**
  * Enforce LTR on both end of the given [text] using unicode BiDi formatting
  * characters LRE and PDF.
  */
 static String enforceLtrInText(String text) {
   return '$LRE$text$PDF';
 }

 /**
  * Enforce the [html] snippet in the desired [direction] regardless of overall
  * context. If the html piece was enclosed by a tag, the direction will be
  * applied to existing tag, otherwise a span tag will be added as wrapper.
  * For this reason, if html snippet start with with tag, this tag must enclose
  * the whole piece. If the tag already has a direction specified, this new one
  * will override existing one in behavior (tested on FF and IE).
  */
 static String _enforceInHtmlHelper(String html, String direction) {
   if (html.startsWith('&lt;')) {
     StringBuffer buffer = new StringBuffer();
     var startIndex = 0;
     Match match = new RegExp('&lt;\\w+').firstMatch(html);
     if (match != null) {
       buffer..add(html.substring(startIndex, match.end))
             ..add(' dir=$direction');
       startIndex = match.end;
     }
     return (buffer..add(html.substring(startIndex))).toString();
   }
   // '\n' is important for FF so that it won't incorrectly merge span groups.
   return '\n&lt;span dir=$direction&gt;$html&lt;/span&gt;';
 }

 /**
  * Apply bracket guard to [str] using html span tag. This is to address the
  * problem of messy bracket display that frequently happens in RTL layout.
  * If [isRtlContext] is true, then we explicitly want to wrap in a span of RTL
  * directionality, regardless of the estimated directionality.
  */
 static String guardBracketInHtml(String str, [bool isRtlContext]) {
   var useRtl = isRtlContext == null ? hasAnyRtl(str) : isRtlContext;
   RegExp matchingBrackets =
       new RegExp(r'(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(&amp;lt;.*?(&amp;gt;)+)');
   return _guardBracketHelper(str, matchingBrackets,
       '&lt;span dir=${useRtl? "rtl" : "ltr"}&gt;', '&lt;/span&gt;');
 }

 /**
  * Apply bracket guard to [str] using LRM and RLM. This is to address the
  * problem of messy bracket display that frequently happens in RTL layout.
  * This version works for both plain text and html, but in some cases is not
  * as good as guardBracketInHtml.
  * If [isRtlContext] is true, then we explicitly want to wrap in a span of RTL
  * directionality, regardless of the estimated directionality.
  */
 static String guardBracketInText(String str, [bool isRtlContext]) {
   var useRtl = isRtlContext == null ? hasAnyRtl(str) : isRtlContext;
   var mark = useRtl ? RLM : LRM;
   return _guardBracketHelper(str,
       new RegExp(r'(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(&lt;.*?&gt;+)'), mark, mark);
 }

 /**
  * (Mostly) reimplements the $&amp; functionality of "replace" in JavaScript.
  * Given a [str] and the [regexp] to match with, optionally supply a string to
  * be inserted [before] the match and/or [after]. For example,
  * `_guardBracketHelper('firetruck', new RegExp('truck'), 'hydrant', '!')`
  * would return 'firehydrant!'.
  */
 // TODO(efortuna): Get rid of this once this is implemented in Dart.
 // See Issue 2979.
 static String _guardBracketHelper(String str, RegExp regexp, [String before,
     String after]) {
   StringBuffer buffer = new StringBuffer();
   var startIndex = 0;
   Iterable matches = regexp.allMatches(str);
   for (Match match in matches) {
     buffer..add(str.substring(startIndex, match.start))
           ..add(before)
           ..add(str.substring(match.start, match.end))
           ..add(after);
     startIndex = match.end;
   }
   return (buffer..add(str.substring(startIndex))).toString();
 }

 /**
  * Estimates the directionality of [text] using the best known
  * general-purpose method (using relative word counts). A
  * TextDirection.UNKNOWN return value indicates completely neutral input.
  * [isHtml] is true if [text] HTML or HTML-escaped.
  *
  * If the number of RTL words is above a certain percentage of the total
  * number of strongly directional words, returns RTL.
  * Otherwise, if any words are strongly or weakly LTR, returns LTR.
  * Otherwise, returns UNKNOWN, which is used to mean `neutral`.
  * Numbers and URLs are counted as weakly LTR.
  */
 static TextDirection estimateDirectionOfText(String text,
                                              {bool isHtml: false}) {
   text = isHtml? stripHtmlIfNeeded(text) : text;
   var rtlCount = 0;
   var total = 0;
   var hasWeaklyLtr = false;
   // Split a string into 'words' for directionality estimation based on
   // relative word counts.
   for (String token in text.split(new RegExp(r'\s+'))) {
     if (startsWithRtl(token)) {
       rtlCount++;
       total++;
     } else if (new RegExp(r'^http://').hasMatch(token)) {
       // Checked if token looks like something that must always be LTR even in
       // RTL text, such as a URL.
       hasWeaklyLtr = true;
     } else if (hasAnyLtr(token)) {
       total++;
     } else if (new RegExp(r'\d').hasMatch(token)) {
       // Checked if token contains any numerals.
       hasWeaklyLtr = true;
     }
   }

   if (total == 0) {
     return hasWeaklyLtr ? TextDirection.LTR : TextDirection.UNKNOWN;
   } else if (rtlCount &gt; _RTL_DETECTION_THRESHOLD * total) {
     return TextDirection.RTL;
   } else {
     return TextDirection.LTR;
   }
 }

 /**
  * Replace the double and single quote directly after a Hebrew character in
  * [str] with GERESH and GERSHAYIM. This is most likely the user's intention.
  */
 static String normalizeHebrewQuote(String str) {
   StringBuffer buf = new StringBuffer();
   if (str.length &gt; 0) {
     buf.add(str.substring(0, 1));
   }
   // Start at 1 because we're looking for the patterns [\u0591-\u05f2])" or
   // [\u0591-\u05f2]'.
   for (int i = 1; i &lt; str.length; i++) {
     if (str.substring(i, i+1) == '"'
         &amp;&amp; new RegExp('[\u0591-\u05f2]').hasMatch(str.substring(i-1, i))) {
       buf.add('\u05f4');
     } else if (str.substring(i, i+1) == "'"
         &amp;&amp; new RegExp('[\u0591-\u05f2]').hasMatch(str.substring(i-1, i))) {
       buf.add('\u05f3');
     } else {
       buf.add(str.substring(i, i+1));
     }
   }
   return buf.toString();
 }

 /**
  * Check the estimated directionality of [str], return true if the piece of
  * text should be laid out in RTL direction. If [isHtml] is true, the string
  * is HTML or HTML-escaped.
  */
 static bool detectRtlDirectionality(String str, {bool isHtml: false}) {
   return estimateDirectionOfText(str, isHtml: isHtml) == TextDirection.RTL;
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="LRE">
<button class="show-code">Code</button>
const         <strong>LRE</strong> <a class="anchor-link"
            href="#LRE"
            title="Permalink to Bidi.LRE">#</a>
        </h4>
        <div class="doc">
<pre class="source">
LRE = '\u202A'
</pre>
</div>
</div>
<div class="field"><h4 id="LRM">
<button class="show-code">Code</button>
const         <strong>LRM</strong> <a class="anchor-link"
            href="#LRM"
            title="Permalink to Bidi.LRM">#</a>
        </h4>
        <div class="doc">
<pre class="source">
LRM = '\u200E'
</pre>
</div>
</div>
<div class="field"><h4 id="PDF">
<button class="show-code">Code</button>
const         <strong>PDF</strong> <a class="anchor-link"
            href="#PDF"
            title="Permalink to Bidi.PDF">#</a>
        </h4>
        <div class="doc">
<pre class="source">
PDF = '\u202C'
</pre>
</div>
</div>
<div class="field"><h4 id="RLE">
<button class="show-code">Code</button>
const         <strong>RLE</strong> <a class="anchor-link"
            href="#RLE"
            title="Permalink to Bidi.RLE">#</a>
        </h4>
        <div class="doc">
<pre class="source">
RLE = '\u202B'
</pre>
</div>
</div>
<div class="field"><h4 id="RLM">
<button class="show-code">Code</button>
const         <strong>RLM</strong> <a class="anchor-link"
            href="#RLM"
            title="Permalink to Bidi.RLM">#</a>
        </h4>
        <div class="doc">
<pre class="source">
RLM = '\u200F'
</pre>
</div>
</div>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="stripHtmlIfNeeded">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>stripHtmlIfNeeded</strong>(<a href="../dart_core/String.html">String</a> text) <a class="anchor-link" href="#stripHtmlIfNeeded"
              title="Permalink to Bidi.stripHtmlIfNeeded">#</a></h4>
<div class="doc">
<p>Returns the input 
<span class="param">text</span> with spaces instead of HTML tags or HTML escapes,
which is helpful for text directionality estimation.
Note: This function should not be used in other contexts.
It does not deal well with many things: comments, script,
elements, style elements, dir attribute,<code>&gt;</code> in quoted attribute values,
etc. But it does handle well enough the most common use cases.
Since the worst that can happen as a result of these shortcomings is that
the wrong directionality will be estimated, we have not invested in
improving this.</p>
<pre class="source">
static String stripHtmlIfNeeded(String text) {
 // The regular expression is simplified for an HTML tag (opening or
 // closing) or an HTML escape. We might want to skip over such expressions
 // when estimating the text directionality.
 return text.replaceAll(new RegExp(r'&lt;[^&gt;]*&gt;|&amp;[^;]+;'), ' ');
}
</pre>
</div>
</div>
<div class="method"><h4 id="startsWithLtr">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>startsWithLtr</strong>(<a href="../dart_core/String.html">String</a> text, [isHtml = false]) <a class="anchor-link" href="#startsWithLtr"
              title="Permalink to Bidi.startsWithLtr">#</a></h4>
<div class="doc">
<p>Determines if the first character in 
<span class="param">text</span> with strong directionality is
LTR. If 
<span class="param">isHtml</span> is true, the text is HTML or HTML-escaped.</p>
<pre class="source">
static bool startsWithLtr(String text, [isHtml=false]) {
 return new RegExp('^[^$_RTL_CHARS]*[$_LTR_CHARS]').hasMatch(
     isHtml? stripHtmlIfNeeded(text) : text);
}
</pre>
</div>
</div>
<div class="method"><h4 id="startsWithRtl">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>startsWithRtl</strong>(<a href="../dart_core/String.html">String</a> text, [isHtml = false]) <a class="anchor-link" href="#startsWithRtl"
              title="Permalink to Bidi.startsWithRtl">#</a></h4>
<div class="doc">
<p>Determines if the first character in 
<span class="param">text</span> with strong directionality is
RTL. If 
<span class="param">isHtml</span> is true, the text is HTML or HTML-escaped.</p>
<pre class="source">
static bool startsWithRtl(String text, [isHtml=false]) {
 return new RegExp('^[^$_LTR_CHARS]*[$_RTL_CHARS]').hasMatch(
     isHtml? stripHtmlIfNeeded(text) : text);
}
</pre>
</div>
</div>
<div class="method"><h4 id="endsWithLtr">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>endsWithLtr</strong>(<a href="../dart_core/String.html">String</a> text, [isHtml = false]) <a class="anchor-link" href="#endsWithLtr"
              title="Permalink to Bidi.endsWithLtr">#</a></h4>
<div class="doc">
<p>Determines if the exit directionality (ie, the last strongly-directional
character in 
<span class="param">text</span> is LTR. If 
<span class="param">isHtml</span> is true, the text is HTML or
HTML-escaped.</p>
<pre class="source">
static bool endsWithLtr(String text, [isHtml=false]) {
 return new RegExp('[$_LTR_CHARS][^$_RTL_CHARS]*\$').hasMatch(
     isHtml? stripHtmlIfNeeded(text) : text);
}
</pre>
</div>
</div>
<div class="method"><h4 id="endsWithRtl">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>endsWithRtl</strong>(<a href="../dart_core/String.html">String</a> text, [isHtml = false]) <a class="anchor-link" href="#endsWithRtl"
              title="Permalink to Bidi.endsWithRtl">#</a></h4>
<div class="doc">
<p>Determines if the exit directionality (ie, the last strongly-directional
character in 
<span class="param">text</span> is RTL. If 
<span class="param">isHtml</span> is true, the text is HTML or
HTML-escaped.</p>
<pre class="source">
static bool endsWithRtl(String text, [isHtml=false]) {
 return new RegExp('[$_RTL_CHARS][^$_LTR_CHARS]*\$').hasMatch(
     isHtml? stripHtmlIfNeeded(text) : text);
}
</pre>
</div>
</div>
<div class="method"><h4 id="hasAnyLtr">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>hasAnyLtr</strong>(<a href="../dart_core/String.html">String</a> text, [isHtml = false]) <a class="anchor-link" href="#hasAnyLtr"
              title="Permalink to Bidi.hasAnyLtr">#</a></h4>
<div class="doc">
<p>Determines if the given 
<span class="param">text</span> has any LTR characters in it.
If 
<span class="param">isHtml</span> is true, the text is HTML or HTML-escaped.</p>
<pre class="source">
static bool hasAnyLtr(String text, [isHtml=false]) {
 return new RegExp(r'[' '$_LTR_CHARS' r']').hasMatch(
     isHtml? stripHtmlIfNeeded(text) : text);
}
</pre>
</div>
</div>
<div class="method"><h4 id="hasAnyRtl">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>hasAnyRtl</strong>(<a href="../dart_core/String.html">String</a> text, [isHtml = false]) <a class="anchor-link" href="#hasAnyRtl"
              title="Permalink to Bidi.hasAnyRtl">#</a></h4>
<div class="doc">
<p>Determines if the given 
<span class="param">text</span> has any RTL characters in it.
If 
<span class="param">isHtml</span> is true, the text is HTML or HTML-escaped.</p>
<pre class="source">
static bool hasAnyRtl(String text, [isHtml=false]) {
 return new RegExp(r'[' '$_RTL_CHARS' r']').hasMatch(
     isHtml? stripHtmlIfNeeded(text) : text);
}
</pre>
</div>
</div>
<div class="method"><h4 id="isRtlLanguage">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>isRtlLanguage</strong>(<a href="../dart_core/String.html">String</a> languageString) <a class="anchor-link" href="#isRtlLanguage"
              title="Permalink to Bidi.isRtlLanguage">#</a></h4>
<div class="doc">
<p>Check if a BCP 47 / III 
<span class="param">languageString</span> indicates an RTL language.</p>
<p>i.e. either:
- a language code explicitly specifying one of the right-to-left scripts,
  e.g. "az-Arab", or
- a language code specifying one of the languages normally written in a
  right-to-left script, e.g. "fa" (Farsi), except ones explicitly
  specifying Latin or Cyrillic script (which are the usual LTR
  alternatives).</p>
<p>The list of right-to-left scripts appears in the 100-199 range in
http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
Hebrew are by far the most widely used. We also recognize Thaana, N'Ko, and
Tifinagh, which also have significant modern usage. The rest (Syriac,
Samaritan, Mandaic, etc.) seem to have extremely limited or no modern usage
and are not recognized.
The languages usually written in a right-to-left script are taken as those
with Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in
http://www.iana.org/assignments/language-subtag-registry,
as well as Sindhi (sd) and Uyghur (ug).
The presence of other subtags of the language code, e.g. regions like EG
(Egypt), is ignored.</p>
<pre class="source">
static bool isRtlLanguage(String languageString) {
 return new RegExp(r'^(ar|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_]'
     r'(Arab|Hebr|Thaa|Nkoo|Tfng))(?!.*[-_](Latn|Cyrl)($|-|_))'
     r'($|-|_)', caseSensitive: false).hasMatch(languageString);
}
</pre>
</div>
</div>
<div class="method"><h4 id="enforceRtlInHtml">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>enforceRtlInHtml</strong>(<a href="../dart_core/String.html">String</a> html) <a class="anchor-link" href="#enforceRtlInHtml"
              title="Permalink to Bidi.enforceRtlInHtml">#</a></h4>
<div class="doc">
<p>Enforce the 
<span class="param">html</span> snippet in RTL directionality regardless of overall
context. If the html piece was enclosed by a tag, the direction will be
applied to existing tag, otherwise a span tag will be added as wrapper.
For this reason, if html snippet start with with tag, this tag must enclose
the whole piece. If the tag already has a direction specified, this new one
will override existing one in behavior (should work on Chrome, FF, and IE
since this was ported directly from the Closure version).</p>
<pre class="source">
static String enforceRtlInHtml(String html) {
 return _enforceInHtmlHelper(html, 'rtl');
}
</pre>
</div>
</div>
<div class="method"><h4 id="enforceRtlInText">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>enforceRtlInText</strong>(<a href="../dart_core/String.html">String</a> text) <a class="anchor-link" href="#enforceRtlInText"
              title="Permalink to Bidi.enforceRtlInText">#</a></h4>
<div class="doc">
<p>Enforce RTL on both end of the given 
<span class="param">text</span> using unicode BiDi formatting
characters RLE and PDF.</p>
<pre class="source">
static String enforceRtlInText(String text) {
 return '$RLE$text$PDF';
}
</pre>
</div>
</div>
<div class="method"><h4 id="enforceLtrInHtml">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>enforceLtrInHtml</strong>(<a href="../dart_core/String.html">String</a> html) <a class="anchor-link" href="#enforceLtrInHtml"
              title="Permalink to Bidi.enforceLtrInHtml">#</a></h4>
<div class="doc">
<p>Enforce the 
<span class="param">html</span> snippet in LTR directionality regardless of overall
context. If the html piece was enclosed by a tag, the direction will be
applied to existing tag, otherwise a span tag will be added as wrapper.
For this reason, if html snippet start with with tag, this tag must enclose
the whole piece. If the tag already has a direction specified, this new one
will override existing one in behavior (tested on FF and IE).</p>
<pre class="source">
static String enforceLtrInHtml(String html) {
 return _enforceInHtmlHelper(html, 'ltr');
}
</pre>
</div>
</div>
<div class="method"><h4 id="enforceLtrInText">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>enforceLtrInText</strong>(<a href="../dart_core/String.html">String</a> text) <a class="anchor-link" href="#enforceLtrInText"
              title="Permalink to Bidi.enforceLtrInText">#</a></h4>
<div class="doc">
<p>Enforce LTR on both end of the given 
<span class="param">text</span> using unicode BiDi formatting
characters LRE and PDF.</p>
<pre class="source">
static String enforceLtrInText(String text) {
 return '$LRE$text$PDF';
}
</pre>
</div>
</div>
<div class="method"><h4 id="guardBracketInHtml">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>guardBracketInHtml</strong>(<a href="../dart_core/String.html">String</a> str, [<a href="../dart_core/bool.html">bool</a> isRtlContext]) <a class="anchor-link" href="#guardBracketInHtml"
              title="Permalink to Bidi.guardBracketInHtml">#</a></h4>
<div class="doc">
<p>Apply bracket guard to 
<span class="param">str</span> using html span tag. This is to address the
problem of messy bracket display that frequently happens in RTL layout.
If 
<span class="param">isRtlContext</span> is true, then we explicitly want to wrap in a span of RTL
directionality, regardless of the estimated directionality.</p>
<pre class="source">
static String guardBracketInHtml(String str, [bool isRtlContext]) {
 var useRtl = isRtlContext == null ? hasAnyRtl(str) : isRtlContext;
 RegExp matchingBrackets =
     new RegExp(r'(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(&amp;lt;.*?(&amp;gt;)+)');
 return _guardBracketHelper(str, matchingBrackets,
     '&lt;span dir=${useRtl? "rtl" : "ltr"}&gt;', '&lt;/span&gt;');
}
</pre>
</div>
</div>
<div class="method"><h4 id="guardBracketInText">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>guardBracketInText</strong>(<a href="../dart_core/String.html">String</a> str, [<a href="../dart_core/bool.html">bool</a> isRtlContext]) <a class="anchor-link" href="#guardBracketInText"
              title="Permalink to Bidi.guardBracketInText">#</a></h4>
<div class="doc">
<p>Apply bracket guard to 
<span class="param">str</span> using LRM and RLM. This is to address the
problem of messy bracket display that frequently happens in RTL layout.
This version works for both plain text and html, but in some cases is not
as good as guardBracketInHtml.
If 
<span class="param">isRtlContext</span> is true, then we explicitly want to wrap in a span of RTL
directionality, regardless of the estimated directionality.</p>
<pre class="source">
static String guardBracketInText(String str, [bool isRtlContext]) {
 var useRtl = isRtlContext == null ? hasAnyRtl(str) : isRtlContext;
 var mark = useRtl ? RLM : LRM;
 return _guardBracketHelper(str,
     new RegExp(r'(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(&lt;.*?&gt;+)'), mark, mark);
}
</pre>
</div>
</div>
<div class="method"><h4 id="estimateDirectionOfText">
<button class="show-code">Code</button>
<a href="../intl/TextDirection.html">TextDirection</a> <strong>estimateDirectionOfText</strong>(<a href="../dart_core/String.html">String</a> text, {<a href="../dart_core/bool.html">bool</a> isHtml: false}) <a class="anchor-link" href="#estimateDirectionOfText"
              title="Permalink to Bidi.estimateDirectionOfText">#</a></h4>
<div class="doc">
<p>Estimates the directionality of 
<span class="param">text</span> using the best known
general-purpose method (using relative word counts). A
TextDirection.UNKNOWN return value indicates completely neutral input.

<span class="param">isHtml</span> is true if 
<span class="param">text</span> HTML or HTML-escaped.</p>
<p>If the number of RTL words is above a certain percentage of the total
number of strongly directional words, returns RTL.
Otherwise, if any words are strongly or weakly LTR, returns LTR.
Otherwise, returns UNKNOWN, which is used to mean <code>neutral</code>.
Numbers and URLs are counted as weakly LTR.</p>
<pre class="source">
static TextDirection estimateDirectionOfText(String text,
                                            {bool isHtml: false}) {
 text = isHtml? stripHtmlIfNeeded(text) : text;
 var rtlCount = 0;
 var total = 0;
 var hasWeaklyLtr = false;
 // Split a string into 'words' for directionality estimation based on
 // relative word counts.
 for (String token in text.split(new RegExp(r'\s+'))) {
   if (startsWithRtl(token)) {
     rtlCount++;
     total++;
   } else if (new RegExp(r'^http://').hasMatch(token)) {
     // Checked if token looks like something that must always be LTR even in
     // RTL text, such as a URL.
     hasWeaklyLtr = true;
   } else if (hasAnyLtr(token)) {
     total++;
   } else if (new RegExp(r'\d').hasMatch(token)) {
     // Checked if token contains any numerals.
     hasWeaklyLtr = true;
   }
 }

 if (total == 0) {
   return hasWeaklyLtr ? TextDirection.LTR : TextDirection.UNKNOWN;
 } else if (rtlCount &gt; _RTL_DETECTION_THRESHOLD * total) {
   return TextDirection.RTL;
 } else {
   return TextDirection.LTR;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="normalizeHebrewQuote">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>normalizeHebrewQuote</strong>(<a href="../dart_core/String.html">String</a> str) <a class="anchor-link" href="#normalizeHebrewQuote"
              title="Permalink to Bidi.normalizeHebrewQuote">#</a></h4>
<div class="doc">
<p>Replace the double and single quote directly after a Hebrew character in

<span class="param">str</span> with GERESH and GERSHAYIM. This is most likely the user's intention.</p>
<pre class="source">
static String normalizeHebrewQuote(String str) {
 StringBuffer buf = new StringBuffer();
 if (str.length &gt; 0) {
   buf.add(str.substring(0, 1));
 }
 // Start at 1 because we're looking for the patterns [\u0591-\u05f2])" or
 // [\u0591-\u05f2]'.
 for (int i = 1; i &lt; str.length; i++) {
   if (str.substring(i, i+1) == '"'
       &amp;&amp; new RegExp('[\u0591-\u05f2]').hasMatch(str.substring(i-1, i))) {
     buf.add('\u05f4');
   } else if (str.substring(i, i+1) == "'"
       &amp;&amp; new RegExp('[\u0591-\u05f2]').hasMatch(str.substring(i-1, i))) {
     buf.add('\u05f3');
   } else {
     buf.add(str.substring(i, i+1));
   }
 }
 return buf.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="detectRtlDirectionality">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>detectRtlDirectionality</strong>(<a href="../dart_core/String.html">String</a> str, {<a href="../dart_core/bool.html">bool</a> isHtml: false}) <a class="anchor-link" href="#detectRtlDirectionality"
              title="Permalink to Bidi.detectRtlDirectionality">#</a></h4>
<div class="doc">
<p>Check the estimated directionality of 
<span class="param">str</span>, return true if the piece of
text should be laid out in RTL direction. If 
<span class="param">isHtml</span> is true, the string
is HTML or HTML-escaped.</p>
<pre class="source">
static bool detectRtlDirectionality(String str, {bool isHtml: false}) {
 return estimateDirectionOfText(str, isHtml: isHtml) == TextDirection.RTL;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-02-26 14:53:02.835</div>
<div>        <p>Except as otherwise <a href="http://code.google.com/policies.html#restrictions">noted</a>, the content of this
        page is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution
        3.0 License</a>, and code samples are licensed under the
        <a href="http://code.google.com/google_bsd_license.html">BSD License</a>.</p>
        <p><a href="http://www.dartlang.org/tos.html">Terms of Service</a> |
        <a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a></p>
        </div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
