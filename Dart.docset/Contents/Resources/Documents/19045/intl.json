{"id":"intl","name":"package:intl/intl.dart","children":[{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Bidi","name":"Bidi","children":[{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"stripHtmlIfNeeded1()","name":"stripHtmlIfNeeded","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"}],"kind":"method","comment":"\nReturns the input [text] with spaces instead of HTML tags or HTML escapes,\nwhich is helpful for text directionality estimation.\nNote: This function should not be used in other contexts.\nIt does not deal well with many things: comments, script,\nelements, style elements, dir attribute,`>` in quoted attribute values,\netc. But it does handle well enough the most common use cases.\nSince the worst that can happen as a result of these shortcomings is that\nthe wrong directionality will be estimated, we have not invested in\nimproving this.\n","line":"99"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"startsWithLtr2()","name":"startsWithLtr","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nDetermines if the first character in [text] with strong directionality is\nLTR. If [isHtml] is true, the text is HTML or HTML-escaped.\n","line":"110"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"startsWithRtl2()","name":"startsWithRtl","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nDetermines if the first character in [text] with strong directionality is\nRTL. If [isHtml] is true, the text is HTML or HTML-escaped.\n","line":"119"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"endsWithLtr2()","name":"endsWithLtr","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nDetermines if the exit directionality (ie, the last strongly-directional\ncharacter in [text] is LTR. If [isHtml] is true, the text is HTML or\nHTML-escaped.\n","line":"129"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"endsWithRtl2()","name":"endsWithRtl","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nDetermines if the exit directionality (ie, the last strongly-directional\ncharacter in [text] is RTL. If [isHtml] is true, the text is HTML or\nHTML-escaped.\n","line":"139"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"hasAnyLtr2()","name":"hasAnyLtr","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nDetermines if the given [text] has any LTR characters in it.\nIf [isHtml] is true, the text is HTML or HTML-escaped.\n","line":"148"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"hasAnyRtl2()","name":"hasAnyRtl","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nDetermines if the given [text] has any RTL characters in it.\nIf [isHtml] is true, the text is HTML or HTML-escaped.\n","line":"157"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"isRtlLanguage1()","name":"isRtlLanguage","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"languageString","name":"languageString","kind":"param"}],"kind":"method","comment":"\nCheck if a BCP 47 / III [languageString] indicates an RTL language.\n\ni.e. either:\n- a language code explicitly specifying one of the right-to-left scripts,\n  e.g. \"az-Arab\", or\n- a language code specifying one of the languages normally written in a\n  right-to-left script, e.g. \"fa\" (Farsi), except ones explicitly\n  specifying Latin or Cyrillic script (which are the usual LTR\n  alternatives).\n\nThe list of right-to-left scripts appears in the 100-199 range in\nhttp://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and\nHebrew are by far the most widely used. We also recognize Thaana, N'Ko, and\nTifinagh, which also have significant modern usage. The rest (Syriac,\nSamaritan, Mandaic, etc.) seem to have extremely limited or no modern usage\nand are not recognized.\nThe languages usually written in a right-to-left script are taken as those\nwith Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in\nhttp://www.iana.org/assignments/language-subtag-registry,\nas well as Sindhi (sd) and Uyghur (ug).\nThe presence of other subtags of the language code, e.g. regions like EG\n(Egypt), is ignored.\n","line":"186"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"enforceRtlInHtml1()","name":"enforceRtlInHtml","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"html","name":"html","kind":"param"}],"kind":"method","comment":"\nEnforce the [html] snippet in RTL directionality regardless of overall\ncontext. If the html piece was enclosed by a tag, the direction will be\napplied to existing tag, otherwise a span tag will be added as wrapper.\nFor this reason, if html snippet start with with tag, this tag must enclose\nthe whole piece. If the tag already has a direction specified, this new one\nwill override existing one in behavior (should work on Chrome, FF, and IE\nsince this was ported directly from the Closure version).\n","line":"201"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"enforceRtlInText1()","name":"enforceRtlInText","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"}],"kind":"method","comment":"\nEnforce RTL on both end of the given [text] using unicode BiDi formatting\ncharacters RLE and PDF.\n","line":"209"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"enforceLtrInHtml1()","name":"enforceLtrInHtml","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"html","name":"html","kind":"param"}],"kind":"method","comment":"\nEnforce the [html] snippet in LTR directionality regardless of overall\ncontext. If the html piece was enclosed by a tag, the direction will be\napplied to existing tag, otherwise a span tag will be added as wrapper.\nFor this reason, if html snippet start with with tag, this tag must enclose\nthe whole piece. If the tag already has a direction specified, this new one\nwill override existing one in behavior (tested on FF and IE).\n","line":"221"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"enforceLtrInText1()","name":"enforceLtrInText","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"}],"kind":"method","comment":"\nEnforce LTR on both end of the given [text] using unicode BiDi formatting\ncharacters LRE and PDF.\n","line":"229"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"_enforceInHtmlHelper2()","name":"_enforceInHtmlHelper","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"html","name":"html","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"direction","name":"direction","kind":"param"}],"kind":"method","comment":"\nEnforce the [html] snippet in the desired [direction] regardless of overall\ncontext. If the html piece was enclosed by a tag, the direction will be\napplied to existing tag, otherwise a span tag will be added as wrapper.\nFor this reason, if html snippet start with with tag, this tag must enclose\nthe whole piece. If the tag already has a direction specified, this new one\nwill override existing one in behavior (tested on FF and IE).\n","isPrivate":true,"line":"241"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"guardBracketInHtml2()","name":"guardBracketInHtml","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"str","name":"str","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"id":"isRtlContext","name":"isRtlContext","kind":"param"}],"kind":"method","comment":"\nApply bracket guard to [str] using html span tag. This is to address the\nproblem of messy bracket display that frequently happens in RTL layout.\nIf [isRtlContext] is true, then we explicitly want to wrap in a span of RTL\ndirectionality, regardless of the estimated directionality.\n","line":"263"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"guardBracketInText2()","name":"guardBracketInText","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"str","name":"str","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"id":"isRtlContext","name":"isRtlContext","kind":"param"}],"kind":"method","comment":"\nApply bracket guard to [str] using LRM and RLM. This is to address the\nproblem of messy bracket display that frequently happens in RTL layout.\nThis version works for both plain text and html, but in some cases is not\nas good as guardBracketInHtml.\nIf [isRtlContext] is true, then we explicitly want to wrap in a span of RTL\ndirectionality, regardless of the estimated directionality.\n","line":"279"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"_guardBracketHelper4()","name":"_guardBracketHelper","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"str","name":"str","kind":"param"},{"ref":{"name":"RegExp","refId":"dart.core/RegExp"},"id":"regexp","name":"regexp","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"before","name":"before","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"after","name":"after","kind":"param","line":"296"}],"kind":"method","comment":"\n(Mostly) reimplements the $& functionality of \"replace\" in JavaScript.\nGiven a [str] and the [regexp] to match with, optionally supply a string to\nbe inserted [before] the match and/or [after]. For example,\n`_guardBracketHelper('firetruck', new RegExp('truck'), 'hydrant', '!')`\nwould return 'firehydrant!'.\n","isPrivate":true,"line":"295"},{"isStatic":true,"returnType":{"name":"TextDirection","refId":"intl/TextDirection"},"id":"estimateDirectionOfText2()","name":"estimateDirectionOfText","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param","line":"323"}],"kind":"method","comment":"\nEstimates the directionality of [text] using the best known\ngeneral-purpose method (using relative word counts). A\nTextDirection.UNKNOWN return value indicates completely neutral input.\n[isHtml] is true if [text] HTML or HTML-escaped.\n\nIf the number of RTL words is above a certain percentage of the total\nnumber of strongly directional words, returns RTL.\nOtherwise, if any words are strongly or weakly LTR, returns LTR.\nOtherwise, returns UNKNOWN, which is used to mean `neutral`.\nNumbers and URLs are counted as weakly LTR.\n","line":"322"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"normalizeHebrewQuote1()","name":"normalizeHebrewQuote","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"str","name":"str","kind":"param"}],"kind":"method","comment":"\nReplace the double and single quote directly after a Hebrew character in\n[str] with GERESH and GERSHAYIM. This is most likely the user's intention.\n","line":"359"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"detectRtlDirectionality2()","name":"detectRtlDirectionality","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"str","name":"str","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nCheck the estimated directionality of [str], return true if the piece of\ntext should be laid out in RTL direction. If [isHtml] is true, the string\nis HTML or HTML-escaped.\n","line":"385"},{"isStatic":true,"id":"LRE","name":"LRE","kind":"variable","line":"61"},{"isStatic":true,"id":"RLE","name":"RLE","kind":"variable","line":"64"},{"isStatic":true,"id":"PDF","name":"PDF","kind":"variable","line":"67"},{"isStatic":true,"id":"LRM","name":"LRM","kind":"variable","line":"70"},{"isStatic":true,"id":"RLM","name":"RLM","kind":"variable","line":"73"},{"ref":{"name":"num","refId":"dart.core/num"},"isStatic":true,"id":"_RTL_DETECTION_THRESHOLD","name":"_RTL_DETECTION_THRESHOLD","kind":"variable","isPrivate":true,"line":"76"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"_LTR_CHARS","name":"_LTR_CHARS","kind":"variable","isPrivate":true,"line":"83"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"_RTL_CHARS","name":"_RTL_CHARS","kind":"variable","isPrivate":true,"line":"86"}],"uri":"dart/pkg/intl/lib/bidi_utils.dart","kind":"class","comment":"\nThis provides utility methods for working with bidirectional text. All\nof the methods are static, and are organized into a class primarily to\ngroup them together for documentation and discoverability.\n","line":"58"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"TextDirection","name":"TextDirection","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"isDirectionChange1()","name":"isDirectionChange","children":[{"ref":{"name":"TextDirection","refId":"intl/TextDirection"},"id":"otherDirection","name":"otherDirection","kind":"param"}],"kind":"method","comment":"\nReturns true if [otherDirection] is known to be different from this\ndirection.\n","line":"48"},{"isStatic":true,"id":"LTR","name":"LTR","kind":"variable","line":"26"},{"isStatic":true,"id":"RTL","name":"RTL","kind":"variable","line":"27"},{"isStatic":true,"id":"UNKNOWN","name":"UNKNOWN","kind":"variable","line":"31"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"value","name":"value","kind":"variable","line":"37"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"spanText","name":"spanText","kind":"variable","line":"40"},{"id":"TextDirection._2()","name":"TextDirection._","children":[{"initializedField":{"name":"value","refId":"intl/TextDirection/value"},"ref":{"name":"String","refId":"dart.core/String"},"id":"value","name":"value","kind":"param"},{"initializedField":{"name":"spanText","refId":"intl/TextDirection/spanText"},"ref":{"name":"String","refId":"dart.core/String"},"id":"spanText","name":"spanText","kind":"param"}],"kind":"constructor","isPrivate":true,"line":"42"}],"uri":"dart/pkg/intl/lib/bidi_utils.dart","kind":"class","comment":"\nBidi stands for Bi-directional text.\nAccording to http://en.wikipedia.org/wiki/Bi-directional_text:\nBi-directional text is text containing text in both text directionalities,\nboth right-to-left (RTL) and left-to-right (LTR). It generally involves text\ncontaining different types of alphabets, but may also refer to boustrophedon,\nwhich is changing text directionality in each row.\n\nThis file provides some utility classes for determining directionality of\ntext, switching CSS layout from LTR to RTL, and other normalizing utilities\nneeded when switching between RTL and LTR formatting.\n\nIt defines the TextDirection class which is used to represent directionality\nof text,\nIn most cases, it is preferable to use bidi_formatter.dart, which provides\nbidi functionality in the given directional context, instead of using\nbidi_utils.dart directly.\n","line":"25"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"BidiFormatter","name":"BidiFormatter","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"htmlEscape1()","name":"htmlEscape","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"}],"kind":"method","comment":"\nEscapes HTML-special characters of [text] so that the result can be\nincluded verbatim in HTML source code, either in an element body or in an\nattribute value.\n","line":"89"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"wrapWithSpan4()","name":"wrapWithSpan","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"true","isOptional":true,"id":"resetDir","name":"resetDir","kind":"param"},{"ref":{"name":"TextDirection","refId":"intl/TextDirection"},"isNamed":true,"isOptional":true,"id":"direction","name":"direction","kind":"param","line":"119"}],"kind":"method","comment":"\nFormats a string of a given (or estimated, if not provided)\n[direction] for use in HTML output of the context directionality, so\nan opposite-directionality string is neither garbled nor garbles what\nfollows it.\nIf the input string's directionality doesn't match the context\ndirectionality, we wrap it with a `span` tag and add a `dir` attribute\n(either \"dir=rtl\" or \"dir=ltr\").\nIf alwaysSpan was true when constructing the formatter, the input is always\nwrapped with `span` tag, skipping the dir attribute when it's not needed.\n\nIf [resetDir] is true and the overall directionality or the exit\ndirectionality of [text] is opposite to the context directionality,\na trailing unicode BiDi mark matching the context directionality is\nappended (LRM or RLM). If [isHtml] is false, we HTML-escape the [text].\n","line":"118"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"wrapWithUnicode4()","name":"wrapWithUnicode","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"true","isOptional":true,"id":"resetDir","name":"resetDir","kind":"param"},{"ref":{"name":"TextDirection","refId":"intl/TextDirection"},"isNamed":true,"isOptional":true,"id":"direction","name":"direction","kind":"param","line":"156"}],"kind":"method","comment":"\nFormat [text] of a known (if specified) or estimated [direction] for use\nin *plain-text* output of the context directionality, so an\nopposite-directionality text is neither garbled nor garbles what follows\nit. Unlike wrapWithSpan, this makes use of unicode BiDi formatting\ncharacters instead of spans for wrapping. The returned string would be\nRLE+text+PDF for RTL text, or LRE+text+PDF for LTR text.\n\nIf [resetDir] is true, and if the overall directionality or the exit\ndirectionality of text are opposite to the context directionality,\na trailing unicode BiDi mark matching the context directionality is\nappended (LRM or RLM).\n\nIn HTML, the *only* valid use of this function is inside of elements that\ndo not allow markup, e.g. an 'option' tag.\nThis function does *not* do HTML-escaping regardless of the value of\n[isHtml]. [isHtml] is used to designate if the text contains HTML (escaped\nor unescaped).\n","line":"155"},{"returnType":{"name":"TextDirection","refId":"intl/TextDirection"},"id":"estimateDirection2()","name":"estimateDirection","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nEstimates the directionality of [text] using the best known\ngeneral-purpose method (using relative word counts). A\nTextDirection.UNKNOWN return value indicates completely neutral input.\n[isHtml] is true if [text] HTML or HTML-escaped.\n","line":"173"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"_resetDir3()","name":"_resetDir","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"text","name":"text","kind":"param"},{"ref":{"name":"TextDirection","refId":"intl/TextDirection"},"id":"direction","name":"direction","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isHtml","name":"isHtml","kind":"param"}],"kind":"method","comment":"\nReturns a unicode BiDi mark matching the surrounding context's [direction]\n(not necessarily the direction of [text]). The function returns an LRM or\nRLM if the overall directionality or the exit directionality of [text] is\nopposite the context directionality. Otherwise\nreturn the empty string. [isHtml] is true if [text] is HTML or\nHTML-escaped.\n","isPrivate":true,"line":"185"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isRTL","name":"isRTL","kind":"property","comment":"Is true if the known context direction for this formatter is RTL. ","line":"82"},{"ref":{"name":"TextDirection","refId":"intl/TextDirection"},"id":"contextDirection","name":"contextDirection","kind":"variable","line":"61"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"_alwaysSpan","name":"_alwaysSpan","kind":"variable","isPrivate":true,"line":"66"},{"id":"BidiFormatter.LTR1()","name":"BidiFormatter.LTR","children":[{"defaultValue":"false","isOptional":true,"id":"alwaysSpan","name":"alwaysSpan","kind":"param"}],"kind":"constructor","comment":"\nCreate a formatting object with a direction. If [alwaysSpan] is true we\nshould always use a `span` tag, even when the input directionality is\nneutral or matches the context, so that the DOM structure of the output\ndoes not depend on the combination of directionalities.\n","line":"74"},{"id":"BidiFormatter.RTL1()","name":"BidiFormatter.RTL","children":[{"defaultValue":"false","isOptional":true,"id":"alwaysSpan","name":"alwaysSpan","kind":"param"}],"kind":"constructor","line":"76"},{"id":"BidiFormatter.UNKNOWN1()","name":"BidiFormatter.UNKNOWN","children":[{"defaultValue":"false","isOptional":true,"id":"alwaysSpan","name":"alwaysSpan","kind":"param"}],"kind":"constructor","line":"78"}],"uri":"dart/pkg/intl/lib/bidi_formatter.dart","kind":"class","comment":"\nBidi stands for Bi-directional text.\nAccording to [Wikipedia](http://en.wikipedia.org/wiki/Bi-directional_text):\nBi-directional text is text containing text in both text directionalities,\nboth right-to-left (RTL) and left-to-right (LTR). It generally involves text\ncontaining different types of alphabets, but may also refer to boustrophedon,\nwhich is changing text directionality in each row.\n\nUtility class for formatting display text in a potentially\nopposite-directionality context without garbling layout issues.\nMostly a very \"slimmed-down\" and dart-ified port of the Closure Birectional\nformatting libary. If there is a utility in the Closure library (or ICU, or\nelsewhere) that you would like this formatter to make available, please\ncontact the Dart team.\n\nProvides the following functionality:\n\n1. *BiDi Wrapping*\nWhen text in one language is mixed into a document in another, opposite-\ndirectionality language, e.g. when an English business name is embedded in a\nHebrew web page, both the inserted string and the text following it may be\ndisplayed incorrectly unless the inserted string is explicitly separated\nfrom the surrounding text in a \"wrapper\" that declares its directionality at\nthe start and then resets it back at the end. This wrapping can be done in\nHTML mark-up (e.g. a 'span dir=rtl' tag) or - only in contexts where mark-up\ncan not be used - in Unicode BiDi formatting codes (LRE|RLE and PDF).\nProviding such wrapping services is the basic purpose of the BiDi formatter.\n\n2. *Directionality estimation*\nHow does one know whether a string about to be inserted into surrounding\ntext has the same directionality? Well, in many cases, one knows that this\nmust be the case when writing the code doing the insertion, e.g. when a\nlocalized message is inserted into a localized page. In such cases there is\nno need to involve the BiDi formatter at all. In the remaining cases, e.g.\nwhen the string is user-entered or comes from a database, the language of\nthe string (and thus its directionality) is not known a priori, and must be\nestimated at run-time. The BiDi formatter does this automatically.\n\n3. *Escaping*\nWhen wrapping plain text - i.e. text that is not already HTML or HTML-\nescaped - in HTML mark-up, the text must first be HTML-escaped to prevent XSS\nattacks and other nasty business. This of course is always true, but the\nescaping cannot be done after the string has already been wrapped in\nmark-up, so the BiDi formatter also serves as a last chance and includes\nescaping services.\n\nThus, in a single call, the formatter will escape the input string as\nspecified, determine its directionality, and wrap it as necessary. It is\nthen up to the caller to insert the return value in the output.\n","line":"58"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"_Stream","name":"_Stream","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"atEnd0()","name":"atEnd","kind":"method","line":"75"},{"id":"next0()","name":"next","kind":"method","line":"77"},{"id":"read1()","name":"read","children":[{"defaultValue":"1","isOptional":true,"id":"howMany","name":"howMany","kind":"param"}],"kind":"method","comment":"\nReturn the next [howMany] items, or as many as there are remaining.\nAdvance the stream by that many positions.\n","line":"83"},{"id":"peek1()","name":"peek","children":[{"defaultValue":"1","isOptional":true,"id":"howMany","name":"howMany","kind":"param"}],"kind":"method","comment":"\nReturn the next [howMany] items, or as many as there are remaining.\nDoes not modify the stream position.\n","line":"93"},{"id":"rest0()","name":"rest","kind":"method","comment":"Return the remaining contents of the stream ","line":"107"},{"returnType":{"name":"int","refId":"dart.core/int"},"id":"findIndex1()","name":"findIndex","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","kind":"param"}],"kind":"method","comment":"\nFind the index of the first element for which [f] returns true.\nAdvances the stream to that position.\n","line":"113"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"findIndexes1()","name":"findIndexes","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","kind":"param"}],"kind":"method","comment":"\nFind the indexes of all the elements for which [f] returns true.\nLeaves the stream positioned at the end.\n","line":"124"},{"returnType":{"name":"int","refId":"dart.core/int"},"id":"nextInteger0()","name":"nextInteger","kind":"method","line":"137"},{"id":"contents","name":"contents","kind":"variable","line":"70"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"variable","line":"71"},{"id":"digitMatcher","name":"digitMatcher","kind":"variable","line":"136"},{"id":"_Stream1()","name":"_Stream","children":[{"initializedField":{"name":"contents","refId":"intl/_Stream/contents"},"id":"contents","name":"contents","kind":"param"}],"kind":"constructor","line":"73"}],"uri":"dart/pkg/intl/lib/src/date_format_helpers.dart","kind":"class","comment":"\nA simple and not particularly general stream class to make parsing\ndates from strings simpler. It is general enough to operate on either\nlists or strings.\n","isPrivate":true,"line":"69"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"_DateBuilder","name":"_DateBuilder","children":[{"returnType":{"name":"void","refId":"void"},"id":"setYear1()","name":"setYear","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"27"},{"returnType":{"name":"void","refId":"void"},"id":"setMonth1()","name":"setMonth","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"28"},{"returnType":{"name":"void","refId":"void"},"id":"setDay1()","name":"setDay","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"29"},{"returnType":{"name":"void","refId":"void"},"id":"setHour1()","name":"setHour","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"30"},{"returnType":{"name":"void","refId":"void"},"id":"setMinute1()","name":"setMinute","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"31"},{"returnType":{"name":"void","refId":"void"},"id":"setSecond1()","name":"setSecond","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"32"},{"returnType":{"name":"void","refId":"void"},"id":"setFractionalSecond1()","name":"setFractionalSecond","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"33"},{"returnType":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"asDate0()","name":"asDate","kind":"method","comment":"\nReturn a date built using our values. If no date portion is set,\nuse the \"Epoch\" of January 1, 1970.\n","line":"39"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"year","name":"year","kind":"variable","line":"15"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"month","name":"month","kind":"variable","line":"16"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"day","name":"day","kind":"variable","line":"17"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"hour","name":"hour","kind":"variable","line":"18"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"minute","name":"minute","kind":"variable","line":"19"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"second","name":"second","kind":"variable","line":"20"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"fractionalSecond","name":"fractionalSecond","kind":"variable","line":"21"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"pm","name":"pm","kind":"variable","line":"22"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"utc","name":"utc","kind":"variable","line":"23"}],"uri":"dart/pkg/intl/lib/src/date_format_helpers.dart","kind":"class","comment":"\nA class for holding onto the data for a date so that it can be built\nup incrementally.\n","isPrivate":true,"line":"12"},{"superclass":{"name":"_DateFormatField","refId":"intl/_DateFormatField"},"id":"_DateFormatPatternField","name":"_DateFormatPatternField","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"format1()","name":"format","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","comment":"Format date according to our specification and return the result. ","line":"111"},{"returnType":{"name":"void","refId":"void"},"id":"parse2()","name":"parse","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"_DateBuilder","refId":"intl/_DateBuilder"},"id":"dateFields","name":"dateFields","kind":"param"}],"kind":"method","comment":"\nParse the date according to our specification and put the result\ninto the correct place in dateFields.\n","line":"119"},{"returnType":{"name":"void","refId":"void"},"id":"parseField2()","name":"parseField","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"_DateBuilder","refId":"intl/_DateBuilder"},"id":"builder","name":"builder","kind":"param"}],"kind":"method","comment":"\nParse a field representing part of a date pattern. Note that we do not\nreturn a value, but rather build up the result in [builder].\n","line":"127"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatField1()","name":"formatField","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","comment":"Formatting logic if we are of type FIELD ","line":"155"},{"id":"formatEra1()","name":"formatEra","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"183"},{"id":"formatYear1()","name":"formatYear","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"189"},{"returnType":{"name":"void","refId":"void"},"id":"handleNumericField3()","name":"handleNumericField","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"setter","name":"setter","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"0","isOptional":true,"id":"offset","name":"offset","kind":"param"}],"kind":"method","comment":"\nWe are given [input] as a stream from which we want to read a date. We\ncan't dynamically build up a date, so we are given a list [dateFields] of\nthe constructor arguments and an [position] at which to set it\n(year,month,day,hour,minute,second,fractionalSecond)\nthen after all parsing is done we construct a date from the arguments.\nThis method handles reading any of the numeric fields. The [offset]\nargument allows us to compensate for zero-based versus one-based values.\n","line":"207"},{"returnType":{"name":"int","refId":"dart.core/int"},"id":"parseEnumeratedString2()","name":"parseEnumeratedString","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"possibilities","name":"possibilities","kind":"param"}],"kind":"method","comment":"\nWe are given [input] as a stream from which we want to read a date. We\ncan't dynamically build up a date, so we are given a list [dateFields] of\nthe constructor arguments and an [position] at which to set it\n(year,month,day,hour,minute,second,fractionalSecond)\nthen after all parsing is done we construct a date from the arguments.\nThis method handles reading any of string fields from an enumerated set.\n","line":"221"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatMonth1()","name":"formatMonth","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"232"},{"returnType":{"name":"void","refId":"void"},"id":"parseMonth2()","name":"parseMonth","children":[{"id":"input","name":"input","kind":"param"},{"id":"dateFields","name":"dateFields","kind":"param"}],"kind":"method","line":"242"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"format24Hours1()","name":"format24Hours","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"253"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatFractionalSeconds1()","name":"formatFractionalSeconds","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"257"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatAmPm1()","name":"formatAmPm","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"268"},{"returnType":{"name":"void","refId":"void"},"id":"parseAmPm2()","name":"parseAmPm","children":[{"id":"input","name":"input","kind":"param"},{"id":"dateFields","name":"dateFields","kind":"param"}],"kind":"method","line":"275"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"format1To12Hours1()","name":"format1To12Hours","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"281"},{"returnType":{"name":"void","refId":"void"},"id":"parse1To12Hours2()","name":"parse1To12Hours","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"_DateBuilder","refId":"intl/_DateBuilder"},"id":"dateFields","name":"dateFields","kind":"param"}],"kind":"method","line":"288"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"format0To11Hours1()","name":"format0To11Hours","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"293"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"format0To23Hours1()","name":"format0To23Hours","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"297"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatStandaloneDay1()","name":"formatStandaloneDay","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"301"},{"returnType":{"name":"void","refId":"void"},"id":"parseStandaloneDay1()","name":"parseStandaloneDay","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"}],"kind":"method","line":"311"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatStandaloneMonth1()","name":"formatStandaloneMonth","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"323"},{"returnType":{"name":"void","refId":"void"},"id":"parseStandaloneMonth2()","name":"parseStandaloneMonth","children":[{"id":"input","name":"input","kind":"param"},{"id":"dateFields","name":"dateFields","kind":"param"}],"kind":"method","line":"336"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatQuarter1()","name":"formatQuarter","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"347"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatDayOfMonth1()","name":"formatDayOfMonth","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"355"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatDayOfWeek1()","name":"formatDayOfWeek","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"359"},{"returnType":{"name":"void","refId":"void"},"id":"parseDayOfWeek1()","name":"parseDayOfWeek","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"}],"kind":"method","line":"365"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatMinutes1()","name":"formatMinutes","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"371"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatSeconds1()","name":"formatSeconds","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"375"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatTimeZoneId1()","name":"formatTimeZoneId","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"379"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatTimeZone1()","name":"formatTimeZone","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"384"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatTimeZoneRFC1()","name":"formatTimeZoneRFC","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","line":"388"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"padTo2()","name":"padTo","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"width","name":"width","kind":"param"},{"ref":{"name":"Object","refId":"dart.core/Object"},"id":"toBePrinted","name":"toBePrinted","kind":"param"}],"kind":"method","comment":"\nReturn a string representation of the object padded to the left with\nzeros. Primarily useful for numbers.\n","line":"396"},{"ref":{"name":"DateSymbols","refId":"date_symbols/DateSymbols"},"id":"symbols","name":"symbols","kind":"property","comment":"Return the symbols for our current locale. ","line":"181"},{"id":"_DateFormatPatternField2()","name":"_DateFormatPatternField","children":[{"id":"pattern","name":"pattern","kind":"param"},{"id":"parent","name":"parent","kind":"param"}],"kind":"constructor","line":"108"}],"uri":"dart/pkg/intl/lib/src/date_format_field.dart","kind":"class","isPrivate":true,"line":"106"},{"superclass":{"name":"_DateFormatField","refId":"intl/_DateFormatField"},"id":"_DateFormatQuotedField","name":"_DateFormatQuotedField","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"fullPattern0()","name":"fullPattern","kind":"method","line":"79"},{"id":"parse2()","name":"parse","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"_DateBuilder","refId":"intl/_DateBuilder"},"id":"dateFields","name":"dateFields","kind":"param"}],"kind":"method","line":"86"},{"returnType":{"name":"void","refId":"void"},"id":"patchQuotes0()","name":"patchQuotes","kind":"method","line":"90"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"_fullPattern","name":"_fullPattern","kind":"variable","isPrivate":true,"line":"77"},{"id":"_DateFormatQuotedField2()","name":"_DateFormatQuotedField","children":[{"id":"pattern","name":"pattern","kind":"param"},{"id":"parent","name":"parent","kind":"param"}],"kind":"constructor","line":"81"}],"uri":"dart/pkg/intl/lib/src/date_format_field.dart","kind":"class","comment":"\nRepresents a literal field with quoted characters in it. This is\nonly slightly more complex than a _DateFormatLiteralField.\n","isPrivate":true,"line":"75"},{"superclass":{"name":"_DateFormatField","refId":"intl/_DateFormatField"},"id":"_DateFormatLiteralField","name":"_DateFormatLiteralField","children":[{"id":"parse2()","name":"parse","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"_DateBuilder","refId":"intl/_DateBuilder"},"id":"dateFields","name":"dateFields","kind":"param"}],"kind":"method","line":"66"},{"id":"_DateFormatLiteralField2()","name":"_DateFormatLiteralField","children":[{"id":"pattern","name":"pattern","kind":"param"},{"id":"parent","name":"parent","kind":"param"}],"kind":"constructor","line":"64"}],"uri":"dart/pkg/intl/lib/src/date_format_field.dart","kind":"class","comment":"\nRepresents a literal field - a sequence of characters that doesn't\nchange according to the date's data. As such, the implementation\nis extremely simple.\n","isPrivate":true,"line":"62"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"_DateFormatField","name":"_DateFormatField","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"fullPattern0()","name":"fullPattern","kind":"method","line":"28"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"30"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"format1()","name":"format","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","comment":"Format date according to our specification and return the result. ","line":"33"},{"returnType":{"name":"void","refId":"void"},"id":"parse2()","name":"parse","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"_DateBuilder","refId":"intl/_DateBuilder"},"id":"dateFields","name":"dateFields","kind":"param"}],"kind":"method","comment":"Abstract method for subclasses to implementing parsing for their format.","line":"40"},{"returnType":{"name":"void","refId":"void"},"id":"parseLiteral1()","name":"parseLiteral","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"Parse a literal field. We just look for the exact input. ","line":"43"},{"returnType":{"name":"void","refId":"void"},"id":"throwFormatException1()","name":"throwFormatException","children":[{"ref":{"name":"_Stream","refId":"intl/_Stream"},"id":"stream","name":"stream","kind":"param"}],"kind":"method","comment":"Throw a format exception with an error message indicating the position.","line":"51"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"width","name":"width","kind":"property","comment":"\nReturn the width of [pattern]. Different widths represent different\nformatting options. See the comment for DateFormat for details.\n","line":"26"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"pattern","name":"pattern","kind":"variable","line":"15"},{"ref":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"parent","name":"parent","kind":"variable","line":"18"},{"id":"_DateFormatField2()","name":"_DateFormatField","children":[{"initializedField":{"name":"pattern","refId":"intl/_DateFormatField/pattern"},"ref":{"name":"String","refId":"dart.core/String"},"id":"pattern","name":"pattern","kind":"param"},{"initializedField":{"name":"parent","refId":"intl/_DateFormatField/parent"},"ref":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"parent","name":"parent","kind":"param"}],"kind":"constructor","line":"20"}],"uri":"dart/pkg/intl/lib/src/date_format_field.dart","kind":"class","comment":"\nThis is a private class internal to DateFormat which is used for formatting\nparticular fields in a template. e.g. if the format is hh:mm:ss then the\nfields would be \"hh\", \":\", \"mm\", \":\", and \"ss\". Each type of field knows\nhow to format that portion of a date.\n","isPrivate":true,"line":"13"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"DateFormat","name":"DateFormat","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"format1()","name":"format","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","comment":"\nReturn a string representing [date] formatted according to our locale\nand internal format.\n","line":"225"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatDuration1()","name":"formatDuration","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"reference","name":"reference","kind":"param"}],"kind":"method","comment":"\nReturns a date string indicating how long ago (3 hours, 2 minutes)\nsomething has happened or how long in the future something will happen\ngiven a [reference] DateTime relative to the current time.\n","line":"237"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"formatDurationFrom2()","name":"formatDurationFrom","children":[{"ref":{"name":"Duration","refId":"dart.core/Duration"},"id":"duration","name":"duration","kind":"param"},{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"date","name":"date","kind":"param"}],"kind":"method","comment":"\nFormats a string indicating how long ago (negative [duration]) or how far\nin the future (positive [duration]) some time is with respect to a\nreference [date].\n","line":"246"},{"returnType":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"parse2()","name":"parse","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"inputString","name":"inputString","kind":"param"},{"defaultValue":"false","isOptional":true,"id":"utc","name":"utc","kind":"param"}],"kind":"method","comment":"\nGiven user input, attempt to parse the [inputString] into the anticipated\nformat, treating it as being in the local timezone.\n","line":"254"},{"returnType":{"name":"DateTime","refId":"dart.core/DateTime"},"id":"parseUTC1()","name":"parseUTC","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"inputString","name":"inputString","kind":"param"}],"kind":"method","comment":"\nGiven user input, attempt to parse the [inputString] into the anticipated\nformat, treating it as being in UTC.\n","line":"269"},{"isStatic":true,"returnType":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"allLocalesWithSymbols0()","name":"allLocalesWithSymbols","kind":"method","comment":"\nReturns a list of all locales for which we have date formatting\ninformation.\n","line":"282"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_d0()","name":"add_d","kind":"method","comment":"\nThe \"add_*\" methods append a particular skeleton to the format, or set\nit as the only format if none was previously set. These are primarily\nuseful for creating compound formats. For example\n      new DateFormat.yMd().add_Hms();\nwould create a date format that prints both the date and the time.\n","line":"347"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_E0()","name":"add_E","kind":"method","line":"348"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_EEEE0()","name":"add_EEEE","kind":"method","line":"349"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_LLL0()","name":"add_LLL","kind":"method","line":"350"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_LLLL0()","name":"add_LLLL","kind":"method","line":"351"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_M0()","name":"add_M","kind":"method","line":"352"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_Md0()","name":"add_Md","kind":"method","line":"353"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_MEd0()","name":"add_MEd","kind":"method","line":"354"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_MMM0()","name":"add_MMM","kind":"method","line":"355"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_MMMd0()","name":"add_MMMd","kind":"method","line":"356"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_MMMEd0()","name":"add_MMMEd","kind":"method","line":"357"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_MMMM0()","name":"add_MMMM","kind":"method","line":"358"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_MMMMd0()","name":"add_MMMMd","kind":"method","line":"359"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_MMMMEEEEd0()","name":"add_MMMMEEEEd","kind":"method","line":"360"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_QQQ0()","name":"add_QQQ","kind":"method","line":"361"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_QQQQ0()","name":"add_QQQQ","kind":"method","line":"362"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_y0()","name":"add_y","kind":"method","line":"363"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yM0()","name":"add_yM","kind":"method","line":"364"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yMd0()","name":"add_yMd","kind":"method","line":"365"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yMEd0()","name":"add_yMEd","kind":"method","line":"366"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yMMM0()","name":"add_yMMM","kind":"method","line":"367"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yMMMd0()","name":"add_yMMMd","kind":"method","line":"368"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yMMMEd0()","name":"add_yMMMEd","kind":"method","line":"369"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yMMMM0()","name":"add_yMMMM","kind":"method","line":"370"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yMMMMd0()","name":"add_yMMMMd","kind":"method","line":"371"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yMMMMEEEEd0()","name":"add_yMMMMEEEEd","kind":"method","line":"372"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yQQQ0()","name":"add_yQQQ","kind":"method","line":"373"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_yQQQQ0()","name":"add_yQQQQ","kind":"method","line":"374"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_H0()","name":"add_H","kind":"method","line":"375"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_Hm0()","name":"add_Hm","kind":"method","line":"376"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_Hms0()","name":"add_Hms","kind":"method","line":"377"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_j0()","name":"add_j","kind":"method","line":"378"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_jm0()","name":"add_jm","kind":"method","line":"379"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_jms0()","name":"add_jms","kind":"method","line":"380"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_jmv0()","name":"add_jmv","kind":"method","line":"381"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_jmz0()","name":"add_jmz","kind":"method","line":"382"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_jv0()","name":"add_jv","kind":"method","line":"383"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_jz0()","name":"add_jz","kind":"method","line":"384"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_m0()","name":"add_m","kind":"method","line":"385"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_ms0()","name":"add_ms","kind":"method","line":"386"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"add_s0()","name":"add_s","kind":"method","line":"387"},{"id":"_useDefaultPattern0()","name":"_useDefaultPattern","kind":"method","comment":"\nWe are being asked to do formatting without having set any pattern.\nUse a default.\n","isPrivate":true,"line":"467"},{"id":"_appendPattern2()","name":"_appendPattern","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"inputPattern","name":"inputPattern","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"defaultValue":"' '","isOptional":true,"id":"separator","name":"separator","kind":"param"}],"kind":"method","comment":"\nSet our pattern, appending it to any existing patterns. Also adds a single\nspace to separate the two.\n","isPrivate":true,"line":"495"},{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"addPattern2()","name":"addPattern","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"inputPattern","name":"inputPattern","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"defaultValue":"' '","isOptional":true,"id":"separator","name":"separator","kind":"param"}],"kind":"method","comment":"\nAdd [inputPattern] to this instance as a pattern. If there was a previous\npattern, then this appends to it, separating the two by [separator].\n[inputPattern] is first looked up in our list of known skeletons.\nIf it's found there, then use the corresponding pattern for this locale.\nIf it's not, then treat [inputPattern] as an explicit pattern.\n","line":"510"},{"id":"_setLocale1()","name":"_setLocale","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"newLocale","name":"newLocale","kind":"param"}],"kind":"method","comment":"\nSet the locale. If the locale can't be found, we also look up\nbased on alternative versions, e.g. if we have no 'en_CA' we will\nlook for 'en' as a fallback. It will also translate en-ca into en_CA.\nNull is also considered a valid value for [newLocale], indicating\nto use the default.\n","isPrivate":true,"line":"540"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"localeExists1()","name":"localeExists","children":[{"id":"localeName","name":"localeName","kind":"param"}],"kind":"method","comment":"\nReturn true if the locale exists, or if it is null. The null case\nis interpreted to mean that we use the default locale.\n","line":"548"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"parsePattern1()","name":"parsePattern","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"pattern","name":"pattern","kind":"param"}],"kind":"method","comment":"Parse the template pattern and return a list of field objects.","line":"559"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"_parsePatternHelper1()","name":"_parsePatternHelper","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"pattern","name":"pattern","kind":"param"}],"kind":"method","comment":"Recursive helper for parsing the template pattern. ","isPrivate":true,"line":"565"},{"returnType":{"name":"_DateFormatField","refId":"intl/_DateFormatField"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"pattern","name":"pattern","kind":"param"}],"kind":"method","comment":"Find elements in a string that are patterns for specific fields.","isPrivate":true,"line":"578"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"_reverse1()","name":"_reverse","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"list","name":"list","kind":"param"}],"kind":"method","comment":"Polyfill for missing library function. ","isPrivate":true,"line":"589"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"locale","name":"locale","kind":"property","comment":"\nReturn the locale code in which we operate, e.g. 'en_US' or 'pt'.\n","line":"276"},{"id":"_formatFields","name":"_formatFields","kind":"property","comment":"\nGetter for [_formatFieldsPrivate] that lazily initializes it.\n","isPrivate":true,"line":"455"},{"id":"pattern","name":"pattern","kind":"property","comment":"Return the pattern that we use to format dates.","line":"526"},{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"_availableSkeletons","name":"_availableSkeletons","kind":"property","comment":"Return the skeletons for our current locale. ","isPrivate":true,"line":"529"},{"ref":{"name":"List","refId":"dart.core/List"},"isStatic":true,"id":"_fieldConstructors","name":"_fieldConstructors","kind":"property","isPrivate":true,"line":"553"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"ABBR_MONTH","name":"ABBR_MONTH","kind":"variable","line":"393"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"DAY","name":"DAY","kind":"variable","line":"394"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"ABBR_WEEKDAY","name":"ABBR_WEEKDAY","kind":"variable","line":"395"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"WEEKDAY","name":"WEEKDAY","kind":"variable","line":"396"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"ABBR_STANDALONE_MONTH","name":"ABBR_STANDALONE_MONTH","kind":"variable","line":"397"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"STANDALONE_MONTH","name":"STANDALONE_MONTH","kind":"variable","line":"398"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"NUM_MONTH","name":"NUM_MONTH","kind":"variable","line":"399"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"NUM_MONTH_DAY","name":"NUM_MONTH_DAY","kind":"variable","line":"400"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"NUM_MONTH_WEEKDAY_DAY","name":"NUM_MONTH_WEEKDAY_DAY","kind":"variable","line":"401"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"ABBR_MONTH_DAY","name":"ABBR_MONTH_DAY","kind":"variable","line":"402"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"ABBR_MONTH_WEEKDAY_DAY","name":"ABBR_MONTH_WEEKDAY_DAY","kind":"variable","line":"403"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"MONTH","name":"MONTH","kind":"variable","line":"404"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"MONTH_DAY","name":"MONTH_DAY","kind":"variable","line":"405"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"MONTH_WEEKDAY_DAY","name":"MONTH_WEEKDAY_DAY","kind":"variable","line":"406"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"ABBR_QUARTER","name":"ABBR_QUARTER","kind":"variable","line":"407"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"QUARTER","name":"QUARTER","kind":"variable","line":"408"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR","name":"YEAR","kind":"variable","line":"409"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_NUM_MONTH","name":"YEAR_NUM_MONTH","kind":"variable","line":"410"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_NUM_MONTH_DAY","name":"YEAR_NUM_MONTH_DAY","kind":"variable","line":"411"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_NUM_MONTH_WEEKDAY_DAY","name":"YEAR_NUM_MONTH_WEEKDAY_DAY","kind":"variable","line":"412"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_ABBR_MONTH","name":"YEAR_ABBR_MONTH","kind":"variable","line":"413"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_ABBR_MONTH_DAY","name":"YEAR_ABBR_MONTH_DAY","kind":"variable","line":"414"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_ABBR_MONTH_WEEKDAY_DAY","name":"YEAR_ABBR_MONTH_WEEKDAY_DAY","kind":"variable","line":"415"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_MONTH","name":"YEAR_MONTH","kind":"variable","line":"416"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_MONTH_DAY","name":"YEAR_MONTH_DAY","kind":"variable","line":"417"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_MONTH_WEEKDAY_DAY","name":"YEAR_MONTH_WEEKDAY_DAY","kind":"variable","line":"418"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_ABBR_QUARTER","name":"YEAR_ABBR_QUARTER","kind":"variable","line":"419"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"YEAR_QUARTER","name":"YEAR_QUARTER","kind":"variable","line":"420"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR24","name":"HOUR24","kind":"variable","line":"421"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR24_MINUTE","name":"HOUR24_MINUTE","kind":"variable","line":"422"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR24_MINUTE_SECOND","name":"HOUR24_MINUTE_SECOND","kind":"variable","line":"423"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR","name":"HOUR","kind":"variable","line":"424"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR_MINUTE","name":"HOUR_MINUTE","kind":"variable","line":"425"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR_MINUTE_SECOND","name":"HOUR_MINUTE_SECOND","kind":"variable","line":"426"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR_MINUTE_GENERIC_TZ","name":"HOUR_MINUTE_GENERIC_TZ","kind":"variable","line":"427"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR_MINUTE_TZ","name":"HOUR_MINUTE_TZ","kind":"variable","line":"428"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR_GENERIC_TZ","name":"HOUR_GENERIC_TZ","kind":"variable","line":"429"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"HOUR_TZ","name":"HOUR_TZ","kind":"variable","line":"430"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"MINUTE","name":"MINUTE","kind":"variable","line":"431"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"MINUTE_SECOND","name":"MINUTE_SECOND","kind":"variable","line":"432"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"SECOND","name":"SECOND","kind":"variable","line":"433"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"_locale","name":"_locale","kind":"variable","isPrivate":true,"line":"436"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"_pattern","name":"_pattern","kind":"variable","isPrivate":true,"line":"443"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"_DateFormatField","refId":"intl/_DateFormatField"}]},"id":"_formatFieldsPrivate","name":"_formatFieldsPrivate","kind":"variable","isPrivate":true,"line":"450"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Pattern","refId":"dart.core/Pattern"}]},"isStatic":true,"id":"_matchers","name":"_matchers","kind":"variable","isPrivate":true,"line":"476"},{"id":"DateFormat2()","name":"DateFormat","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"newPattern","name":"newPattern","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","comment":"\nCreates a new DateFormat, using the format specified by [newPattern]. For\nforms that match one of our predefined skeletons, we look up the\ncorresponding pattern in [locale] (or in the default locale if none is\nspecified) and use the resulting full format string. This is the\npreferred usage, but if [newPattern] does not match one of the skeletons,\nthen it is used as a format directly, but will not be adapted to suit\nthe locale.\n\nFor example, in an en_US locale, specifying the skeleton\n    new DateFormat('yMEd');\nor the explicit\n    new DateFormat('EEE, M/d/y');\nwould produce the same result, a date of the form\n    Wed, 6/27/2012\nThe first version would produce a different format string if used in\nanother locale, but the second format would always be the same.\n\nIf [locale] does not exist in our set of supported locales then an\n[ArgumentError] is thrown.\n","line":"211"},{"id":"DateFormat.d1()","name":"DateFormat.d","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","comment":"\nThe named constructors for this class are all conveniences for creating\ninstances using one of the known \"skeleton\" formats, and having code\ncompletion support for discovering those formats.\nSo,\n    new DateFormat.yMd(\"en_US\")\nis equivalent to\n    new DateFormat(\"yMd\", \"en_US\")\nTo create a compound format you can use these constructors in combination\nwith the add_ methods below. e.g.\n    new DateFormat.yMd().add_Hms();\nIf the optional [locale] is omitted, the format will be created using the\ndefault locale in [Intl.systemLocale].\n","line":"298"},{"id":"DateFormat.E1()","name":"DateFormat.E","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"299"},{"id":"DateFormat.EEEE1()","name":"DateFormat.EEEE","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"300"},{"id":"DateFormat.LLL1()","name":"DateFormat.LLL","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"301"},{"id":"DateFormat.LLLL1()","name":"DateFormat.LLLL","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"302"},{"id":"DateFormat.M1()","name":"DateFormat.M","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"303"},{"id":"DateFormat.Md1()","name":"DateFormat.Md","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"304"},{"id":"DateFormat.MEd1()","name":"DateFormat.MEd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"305"},{"id":"DateFormat.MMM1()","name":"DateFormat.MMM","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"306"},{"id":"DateFormat.MMMd1()","name":"DateFormat.MMMd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"307"},{"id":"DateFormat.MMMEd1()","name":"DateFormat.MMMEd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"308"},{"id":"DateFormat.MMMM1()","name":"DateFormat.MMMM","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"309"},{"id":"DateFormat.MMMMd1()","name":"DateFormat.MMMMd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"310"},{"id":"DateFormat.MMMMEEEEd1()","name":"DateFormat.MMMMEEEEd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"311"},{"id":"DateFormat.QQQ1()","name":"DateFormat.QQQ","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"312"},{"id":"DateFormat.QQQQ1()","name":"DateFormat.QQQQ","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"313"},{"id":"DateFormat.y1()","name":"DateFormat.y","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"314"},{"id":"DateFormat.yM1()","name":"DateFormat.yM","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"315"},{"id":"DateFormat.yMd1()","name":"DateFormat.yMd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"316"},{"id":"DateFormat.yMEd1()","name":"DateFormat.yMEd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"317"},{"id":"DateFormat.yMMM1()","name":"DateFormat.yMMM","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"318"},{"id":"DateFormat.yMMMd1()","name":"DateFormat.yMMMd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"319"},{"id":"DateFormat.yMMMEd1()","name":"DateFormat.yMMMEd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"320"},{"id":"DateFormat.yMMMM1()","name":"DateFormat.yMMMM","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"321"},{"id":"DateFormat.yMMMMd1()","name":"DateFormat.yMMMMd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"322"},{"id":"DateFormat.yMMMMEEEEd1()","name":"DateFormat.yMMMMEEEEd","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"323"},{"id":"DateFormat.yQQQ1()","name":"DateFormat.yQQQ","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"324"},{"id":"DateFormat.yQQQQ1()","name":"DateFormat.yQQQQ","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"325"},{"id":"DateFormat.H1()","name":"DateFormat.H","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"326"},{"id":"DateFormat.Hm1()","name":"DateFormat.Hm","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"327"},{"id":"DateFormat.Hms1()","name":"DateFormat.Hms","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"328"},{"id":"DateFormat.j1()","name":"DateFormat.j","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"329"},{"id":"DateFormat.jm1()","name":"DateFormat.jm","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"330"},{"id":"DateFormat.jms1()","name":"DateFormat.jms","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"331"},{"id":"DateFormat.jmv1()","name":"DateFormat.jmv","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"332"},{"id":"DateFormat.jmz1()","name":"DateFormat.jmz","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"333"},{"id":"DateFormat.jv1()","name":"DateFormat.jv","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"334"},{"id":"DateFormat.jz1()","name":"DateFormat.jz","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"335"},{"id":"DateFormat.m1()","name":"DateFormat.m","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"336"},{"id":"DateFormat.ms1()","name":"DateFormat.ms","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"337"},{"id":"DateFormat.s1()","name":"DateFormat.s","children":[{"isOptional":true,"id":"locale","name":"locale","kind":"param"}],"kind":"constructor","line":"338"}],"uri":"dart/pkg/intl/lib/date_format.dart","kind":"class","comment":"\nDateFormat is for formatting and parsing dates in a locale-sensitive\nmanner.\nIt allows the user to choose from a set of standard date time formats as well\nas specify a customized pattern under certain locales. Date elements that\nvary across locales include month name, week name, field order, etc.\nWe also allow the user to use any customized pattern to parse or format\ndate-time strings under certain locales. Date elements that vary across\nlocales include month name, weekname, field, order, etc.\n\nThe actual date for the locales must be obtained. This can currently be done\nin one of three ways, determined by which library you import. If you only\nwant to use en_US formatting you can use it directly, as a copy of that\nlocale is hard-coded into the formatter. In all other cases,\nthe [initializeDateFormatting] method must be called and will return a future\nthat is complete once the locale data is available. The result of the future\nisn't important, but the data for that locale is available to the date\nformatting and parsing once it completes.\n\nThe easiest option is that the data may be available locally, imported in a\nlibrary that contains data for all the locales.\n      import 'package:intl/date_symbol_data_local.dart';\n      initializeDateFormatting(\"en_US\", null).then((_) => runMyCode());\n\nIf we are running outside of a browser, we may want to read the data\nfrom files in the file system.\n      import 'package:intl/date_symbol_data_file.dart';\n      initializeDateFormatting(\"de_DE\", null).then((_) => runMyCode());\n\nIf we are running in a browser, we may want to read the data from the\nserver using the XmlHttpRequest mechanism.\n      import 'package:intl/date_symbol_data_http_request.dart';\n      initializeDateFormatting(\"pt_BR\", null).then((_) => runMyCode());\n\nThe code in example/basic/basic_example.dart shows a full example of\nusing this mechanism.\n\nOnce we have the locale data, we need to specify the particular format.\nThis library uses the ICU/JDK date/time pattern specification both for\ncomplete format specifications and also the abbreviated \"skeleton\" form\nwhich can also adapt to different locales and is preferred where available.\n\nSkeletons: These can be specified either as the ICU constant name or as the\nskeleton to which it resolves. The supported set of skeletons is as follows\n     ICU Name                   Skeleton\n     --------                   --------\n     DAY                          d\n     ABBR_WEEKDAY                 E\n     WEEKDAY                      EEEE\n     ABBR_STANDALONE_MONTH        LLL\n     STANDALONE_MONTH             LLLL\n     NUM_MONTH                    M\n     NUM_MONTH_DAY                Md\n     NUM_MONTH_WEEKDAY_DAY        MEd\n     ABBR_MONTH                   MMM\n     ABBR_MONTH_DAY               MMMd\n     ABBR_MONTH_WEEKDAY_DAY       MMMEd\n     MONTH                        MMMM\n     MONTH_DAY                    MMMMd\n     MONTH_WEEKDAY_DAY            MMMMEEEEd\n     ABBR_QUARTER                 QQQ\n     QUARTER                      QQQQ\n     YEAR                         y\n     YEAR_NUM_MONTH               yM\n     YEAR_NUM_MONTH_DAY           yMd\n     YEAR_NUM_MONTH_WEEKDAY_DAY   yMEd\n     YEAR_ABBR_MONTH              yMMM\n     YEAR_ABBR_MONTH_DAY          yMMMd\n     YEAR_ABBR_MONTH_WEEKDAY_DAY  yMMMEd\n     YEAR_MONTH                   yMMMM\n     YEAR_MONTH_DAY               yMMMMd\n     YEAR_MONTH_WEEKDAY_DAY       yMMMMEEEEd\n     YEAR_ABBR_QUARTER            yQQQ\n     YEAR_QUARTER                 yQQQQ\n     HOUR24                       H\n     HOUR24_MINUTE                Hm\n     HOUR24_MINUTE_SECOND         Hms\n     HOUR                         j\n     HOUR_MINUTE                  jm\n     HOUR_MINUTE_SECOND           jms\n     HOUR_MINUTE_GENERIC_TZ       jmv\n     HOUR_MINUTE_TZ               jmz\n     HOUR_GENERIC_TZ              jv\n     HOUR_TZ                      jz\n     MINUTE                       m\n     MINUTE_SECOND                ms\n     SECOND                       s\n\nExamples Using the US Locale:\n\n     Pattern                           Result\n     ----------------                  -------\n     new DateFormat.yMd()             -> 07/10/1996\n     new DateFormat(\"yMd\")            -> 07/10/1996\n     new DateFormat.yMMMMd(\"en_US\")   -> July 10, 1996\n     new DateFormat(\"Hm\", \"en_US\")    -> 12:08 PM\n     new DateFormat.yMd().Hm()        -> 07/10/1996 12:08 PM\n\nExplicit Pattern Syntax: Formats can also be specified with a pattern string.\nThe skeleton forms will resolve to explicit patterns of this form, but will\nalso adapt to different patterns in different locales.\nThe following characters are reserved:\n\n    Symbol   Meaning                Presentation        Example\n    ------   -------                ------------        -------\n    G        era designator         (Text)              AD\n    y        year                   (Number)            1996\n    M        month in year          (Text & Number)     July & 07\n    L        standalone month       (Text & Number)     July & 07\n    d        day in month           (Number)            10\n    c        standalone day         (Number)            10\n    h        hour in am/pm (1~12)   (Number)            12\n    H        hour in day (0~23)     (Number)            0\n    m        minute in hour         (Number)            30\n    s        second in minute       (Number)            55\n    S        fractional second      (Number)            978\n    E        day of week            (Text)              Tuesday\n    D        day in year            (Number)            189\n    a        am/pm marker           (Text)              PM\n    k        hour in day (1~24)     (Number)            24\n    K        hour in am/pm (0~11)   (Number)            0\n    z        time zone              (Text)              Pacific Standard Time\n    Z        time zone (RFC 822)    (Number)            -0800\n    v        time zone (generic)    (Text)              Pacific Time\n    Q        quarter                (Text)              Q3\n    '        escape for text        (Delimiter)         'Date='\n    ''       single quote           (Literal)           'o''clock'\n\nThe count of pattern letters determine the format.\n\n**Text**:\n* 5 pattern letters--use narrow form for standalone. Otherwise does not apply\n* 4 or more pattern letters--use full form,\n* 3 pattern letters--use short or abbreviated form if one exists\n* less than 3--use numeric form if one exists\n\n**Number**: the minimum number of digits. Shorter numbers are zero-padded to\nthis amount (e.g. if \"m\" produces \"6\", \"mm\" produces \"06\"). Year is handled\nspecially; that is, if the count of 'y' is 2, the Year will be truncated to\n2 digits. (e.g., if \"yyyy\" produces \"1997\", \"yy\" produces \"97\".) Unlike other\nfields, fractional seconds are padded on the right with zero.\n\n**(Text & Number)**: 3 or over, use text, otherwise use number.\n\nAny characters not in the pattern will be treated as quoted text. For\ninstance, characters like ':', '.', ' ', '#' and '@' will appear in the\nresulting text even though they are not enclosed in single quotes. In our\ncurrent pattern usage, not all letters have meanings. But those unused\nletters are strongly discouraged to be used as quoted text without quotes,\nbecause we may use other letters as pattern characters in the future.\n\nExamples Using the US Locale:\n\n    Format Pattern                     Result\n    --------------                     -------\n    \"yyyy.MM.dd G 'at' HH:mm:ss vvvv\"  1996.07.10 AD at 15:08:56 Pacific Time\n    \"EEE, MMM d, ''yy\"                 Wed, July 10, '96\n    \"h:mm a\"                           12:08 PM\n    \"hh 'o''clock' a, zzzz\"            12 o'clock PM, Pacific Daylight Time\n    \"K:mm a, vvv\"                      0:00 PM, PT\n    \"yyyyy.MMMMM.dd GGG hh:mm aaa\"     01996.July.10 AD 12:08 PM\n\nWhen parsing a date string using the abbreviated year pattern (\"yy\"),\nDateFormat must interpret the abbreviated year relative to some\ncentury. It does this by adjusting dates to be within 80 years before and 20\nyears after the time the parse function is called. For example, using a\npattern of \"MM/dd/yy\" and a DateParse instance created on Jan 1, 1997,\nthe string \"01/11/12\" would be interpreted as Jan 11, 2012 while the string\n\"05/04/64\" would be interpreted as May 4, 1964. During parsing, only\nstrings consisting of exactly two digits, as defined by {@link\njava.lang.Character#isDigit(char)}, will be parsed into the default\ncentury. Any other numeric string, such as a one digit string, a three or\nmore digit string will be interpreted as its face value.\n\nIf the year pattern does not have exactly two 'y' characters, the year is\ninterpreted literally, regardless of the number of digits. So using the\npattern \"MM/dd/yyyy\", \"01/11/12\" parses to Jan 11, 12 A.D.\n","line":"188"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Intl","name":"Intl","children":[{"returnType":{"name":"DateFormat","refId":"intl/DateFormat"},"id":"date2()","name":"date","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"pattern","name":"pattern","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"desiredLocale","name":"desiredLocale","kind":"param"}],"kind":"method","comment":"\nReturn a new date format using the specified [pattern].\nIf [desiredLocale] is not specified, then we default to [locale].\n","line":"94"},{"isStatic":true,"returnType":{"name":"Future","refId":"dart.async/Future","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"message6()","name":"message","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message_str","name":"message_str","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"defaultValue":"''","isOptional":true,"id":"desc","name":"desc","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"isNamed":true,"defaultValue":"const{}","isOptional":true,"id":"examples","name":"examples","kind":"param","line":"132"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"locale","name":"locale","kind":"param","line":"132"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"name","name":"name","kind":"param","line":"132"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"isNamed":true,"isOptional":true,"id":"args","name":"args","kind":"param","line":"133"}],"kind":"method","comment":"\nReturns a message that can be internationalized. It takes a\n[message_str] that will be translated, which may be interpolated\nbased on one or more variables, a [desc] providing a description of usage\nfor the [message_str], and a map of [examples] for each data element to be\nsubstituted into the message. For example, if message=\"Hello, $name\", then\nexamples = {'name': 'Sparky'}. If not using the user's default locale, or\nif the locale is not easily detectable, explicitly pass [locale].\nThe values of [desc] and [examples] are not used at run-time but are only\nmade available to the translators, so they MUST be simple Strings available\nat compile time: no String interpolation or concatenation.\nThe expected usage of this is inside a function that takes as parameters\nthe variables used in the interpolated string, and additionally also a\nlocale (optional).\nUltimately, the information about the enclosing function and its arguments\nwill be extracted automatically but for the time being it must be passed\nexplicitly in the [name] and [args] arguments.\n","line":"131"},{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_localeExists1()","name":"_localeExists","children":[{"id":"localeName","name":"localeName","kind":"param"}],"kind":"method","comment":"\nReturn true if the locale exists, or if it is null. The null case\nis interpreted to mean that we use the default locale.\n","isPrivate":true,"line":"148"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"verifiedLocale3()","name":"verifiedLocale","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"newLocale","name":"newLocale","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"localeExists","name":"localeExists","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"defaultValue":"_throwLocaleError","isOptional":true,"id":"onFailure","name":"onFailure","kind":"param","line":"163"}],"kind":"method","comment":"\nGiven [newLocale] return a locale that we have data for that is similar\nto it, if possible.\nIf [newLocale] is found directly, return it. If it can't be found, look up\nbased on just the language (e.g. 'en_CA' -> 'en'). Also accepts '-'\nas a separator and changes it into '_' for lookup, and changes the\ncountry to uppercase.\nNote that null is interpreted as meaning the default locale, so if\n[newLocale] is null it will be returned.\n","line":"162"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"_throwLocaleError1()","name":"_throwLocaleError","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"localeName","name":"localeName","kind":"param"}],"kind":"method","comment":"\nThe default action if a locale isn't found in verifiedLocale. Throw\nan exception indicating the locale isn't correct.\n","isPrivate":true,"line":"186"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"_shortLocale1()","name":"_shortLocale","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"aLocale","name":"aLocale","kind":"param"}],"kind":"method","comment":"Return the short version of a locale name, e.g. 'en_US' => 'en' ","isPrivate":true,"line":"191"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"canonicalizedLocale1()","name":"canonicalizedLocale","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"aLocale","name":"aLocale","kind":"param"}],"kind":"method","comment":"\nReturn the name [aLocale] turned into xx_YY where it might possibly be\nin the wrong case or with a hyphen instead of an underscore. If\n[aLocale] is null, for example, if you tried to get it from IE,\nreturn the current system locale.\n","line":"202"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"plural3()","name":"plural","children":[{"id":"howMany","name":"howMany","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"cases","name":"cases","kind":"param"},{"ref":{"name":"num","refId":"dart.core/num"},"defaultValue":"0","isOptional":true,"id":"offset","name":"offset","kind":"param"}],"kind":"method","comment":"\nSupport method for message formatting. Select the correct plural form from\n[cases] given [howMany].\n","line":"222"},{"isStatic":true,"id":"withLocale2()","name":"withLocale","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"locale","name":"locale","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"message_function","name":"message_function","kind":"param"}],"kind":"method","comment":"\nFormat the given function with a specific [locale], given a\n[message_function] that takes no parameters. The [message_function] can be\na simple message function that just returns the result of `Intl.message()`\nit can be a wrapper around a message function that takes arguments, or it\ncan be something more complex that manipulates multiple message\nfunctions.\n\nIn either case, the purpose of this is to delay calling [message_function]\nuntil the proper locale has been set. This returns the result of calling\n[msg_function], which could be of an arbitrary type.\n","line":"239"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"select2()","name":"select","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"choice","name":"choice","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"cases","name":"cases","kind":"param"}],"kind":"method","comment":"\nSupport method for message formatting. Select the correct exact (gender,\nusually) form from [cases] given the user [choice].\n","line":"255"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"getCurrentLocale0()","name":"getCurrentLocale","kind":"method","comment":"\nAccessor for the current locale. This should always == the default locale,\nunless for some reason this gets called inside a message that resets the\nlocale.\n","line":"270"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"locale","name":"locale","kind":"property","comment":"\nReturn the locale for this instance. If none was set, the locale will\nbe the default.\n","line":"142"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"_locale","name":"_locale","kind":"variable","isPrivate":true,"line":"74"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"_defaultLocale","name":"_defaultLocale","kind":"variable","isPrivate":true,"line":"80"},{"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"systemLocale","name":"systemLocale","kind":"variable","line":"88"},{"id":"Intl1()","name":"Intl","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"aLocale","name":"aLocale","kind":"param"}],"kind":"constructor","comment":"\nConstructor optionally [aLocale] for specifics of the language\nlocale to be used, otherwise, we will attempt to infer it (acceptable if\nDart is running on the client, we can infer from the browser/client\npreferences).\n","line":"105"}],"kind":"class","comment":"\nThe Intl class provides a common entry point for internationalization\nrelated tasks. An Intl instance can be created for a particular locale\nand used to create a date format via `anIntl.date()`. Static methods\non this class are also used in message formatting.\n\nMessage example:\n    '''I see ${Intl.plural(num_people,\n              {'0': 'no one at all',\n               '1': 'one other person',\n               'other': '$num_people other people'})} in $place.''''\n\nUsage examples:\n     today(date) => Intl.message(\n         \"Today's date is $date\",\n         desc: 'Indicate the current date',\n         examples: {'date' : 'June 8, 2012'});\n     print(today(new DateTime.now());\n\n     msg({num_people, place}) => Intl.message(\n          '''I see ${Intl.plural(num_people,\n            {'0': 'no one at all',\n             '1': 'one other person',\n             'other': '$num_people other people'})} in $place.'''',\n         desc: 'Description of how many people are seen as program start.',\n         examples: {'num_people': 3, 'place': 'London'});\n\nCalling `msg({'num_people': 2, 'place': 'Athens'});` would\nproduce \"I see 2 other people in Athens.\" as output in the default locale.\n\nTo use a locale other than the default, use the `withLocale` function.\n      var todayString = new DateFormat(\"pt_BR\").format(new DateTime.now());\n      print(withLocale(\"pt_BR\", () => today(todayString));\n\nSee `tests/message_format_test.dart` for more examples.\n","line":"69"}],"uri":"dart/pkg/intl/lib/intl.dart","kind":"library","comment":"\nThis library provides internationalization and localization. This includes\nmessage formatting and replacement, date and number formatting and parsing,\nand utilities for working with Bidirectional text.\n\nFor things that require locale or other data, there are multiple different\nways of making that data available, which may require importing different\nlibraries. See the class comments for more details.\n\nThere is also a simple example application that can be found in the\n`example/basic` directory.\n","line":"17"}