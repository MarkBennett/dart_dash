{"id":"scheduled_test","name":"package:scheduled_test/scheduled_test.dart","children":[{"returnType":{"name":"Future","refId":"dart.async/Future"},"id":"wrapFuture1()","name":"wrapFuture","children":[{"ref":{"name":"Future","refId":"dart.async/Future"},"id":"future","name":"future","kind":"param"}],"kind":"method","comment":"Like [wrapAsync], this ensures that the current task queue waits for\nout-of-band asynchronous code, and that errors raised in that code are\nhandled correctly. However, [wrapFuture] wraps a [Future] chain rather than\na single callback.\n\nThe returned [Future] completes to the same value or error as [future].","line":"335"},{"returnType":{"name":"void","refId":"void"},"id":"_ensureInitialized0()","name":"_ensureInitialized","kind":"method","comment":"Ensures that the global configuration for `scheduled_test` has been\ninitialized.","isPrivate":true,"line":"317"},{"returnType":{"name":"void","refId":"void"},"id":"_setUpScheduledTest1()","name":"_setUpScheduledTest","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"setUpFn","name":"setUpFn","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","uri":"dart/sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"Registers callbacks for [unittest.setUp] and [unittest.tearDown] that set up\nand tear down the scheduled test infrastructure.","isPrivate":true,"line":"298"},{"returnType":{"name":"void","refId":"void"},"id":"_ensureSetUpForTopLevel0()","name":"_ensureSetUpForTopLevel","kind":"method","comment":"If we're in the top-level scope (that is, not in any [group]s) and\n[unittest.setUp] hasn't been called yet, call it.","isPrivate":true,"line":"291"},{"returnType":{"name":"void","refId":"void"},"id":"setUp1()","name":"setUp","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"setUpFn","name":"setUpFn","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","uri":"dart/sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"Register a [setUp] function for a test [group]. This has the same semantics\nas [unittest.setUp]. Tasks may be scheduled using [schedule] within\n[setUpFn], and [currentSchedule] may be accessed as well.\n\nNote that there is no associated [tearDown] function. Instead, tasks should\nbe scheduled for [currentSchedule.onComplete] or\n[currentSchedule.onException]. These tasks will be run after each test's\nschedule is completed.","line":"282"},{"returnType":{"name":"Future","refId":"dart.async/Future"},"id":"schedule2()","name":"schedule","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"fn","name":"fn","children":[{"id":"Function","name":"Function","uri":"dart/sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"description","name":"description","kind":"param"}],"kind":"method","comment":"Schedules a task, [fn], to run asynchronously as part of the main task queue\nof [currentSchedule]. Tasks will be run in the order they're scheduled. If\n[fn] returns a [Future], tasks after it won't be run until that [Future]\ncompletes.\n\nThe return value will be completed once the scheduled task has finished\nrunning. Its return value is the same as the return value of [fn], or the\nvalue it completes to if it's a [Future].\n\nIf [description] is passed, it's used to describe the task for debugging\npurposes when an error occurs.\n\nIf this is called when a task queue is currently running, it will run [fn]\non the next event loop iteration rather than adding it to a queue. The\ncurrent task will not complete until [fn] (and any [Future] it returns) has\nfinished running. Any errors in [fn] will automatically be handled.","line":"271"},{"returnType":{"name":"void","refId":"void"},"id":"group2()","name":"group","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"description","name":"description","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"body","name":"body","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","uri":"dart/sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"Creates a new named group of tests. This has the same semantics as\n[unittest.group].","line":"245"},{"returnType":{"name":"void","refId":"void"},"id":"_test3()","name":"_test","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"description","name":"description","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"body","name":"body","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","uri":"dart/sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"testFn","name":"testFn","kind":"param"}],"kind":"method","isPrivate":true,"line":"214"},{"returnType":{"name":"void","refId":"void"},"id":"solo_test2()","name":"solo_test","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"description","name":"description","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"body","name":"body","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","uri":"dart/sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"Creates a new test case with the given description and body that will be the\nonly test run in this file. This has the same semantics as\n[unittest.solo_test].","line":"211"},{"returnType":{"name":"void","refId":"void"},"id":"test2()","name":"test","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"description","name":"description","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"body","name":"body","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","uri":"dart/sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"Creates a new test case with the given description and body. This has the\nsame semantics as [unittest.test].","line":"205"},{"returnType":{"name":"Schedule","refId":"schedule/Schedule"},"id":"currentSchedule0()","name":"currentSchedule","kind":"method","comment":"The [Schedule] for the current test. This is used to add new tasks and\ninspect the state of the schedule.\n\nThis is `null` when there's no test currently running.","line":"196"},{"ref":{"name":"Schedule","refId":"schedule/Schedule"},"id":"currentSchedule","name":"currentSchedule","kind":"property","comment":"The [Schedule] for the current test. This is used to add new tasks and\ninspect the state of the schedule.\n\nThis is `null` when there's no test currently running.","line":"196"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"_setUpForTopLevel","name":"_setUpForTopLevel","kind":"variable","isPrivate":true,"line":"287"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"_inGroup","name":"_inGroup","kind":"variable","isPrivate":true,"line":"241"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"_setUpFn","name":"_setUpFn","kind":"variable","isPrivate":true,"line":"201"},{"ref":{"name":"Schedule","refId":"schedule/Schedule"},"id":"_currentSchedule","name":"_currentSchedule","kind":"variable","isPrivate":true,"line":"197"}],"uri":"dart/pkg/scheduled_test/lib/scheduled_test.dart","kind":"library","comment":"A package for writing readable tests of asynchronous behavior.\n\nThis package works by building up a queue of asynchronous tasks called a\n\"schedule\", then executing those tasks in order. This allows the tests to\nread like synchronous, linear code, despite executing asynchronously.\n\nThe `scheduled_test` package is built on top of `unittest`, and should be\nimported instead of `unittest`. It provides its own version of [group],\n[test], and [setUp], and re-exports most other APIs from unittest.\n\nTo schedule a task, call the [schedule] function. For example:\n\n    import 'package:scheduled_test/scheduled_test.dart';\n\n    void main() {\n      test('writing to a file and reading it back should work', () {\n        schedule(() {\n          // The schedule won't proceed until the returned Future has\n          // completed.\n          return new File(\"output.txt\").writeAsString(\"contents\");\n        });\n\n        schedule(() {\n          return new File(\"output.txt\").readAsString().then((contents) {\n            // The normal unittest matchers can still be used.\n            expect(contents, equals(\"contents\"));\n          });\n        });\n      });\n    }\n\n## Setting Up and Tearing Down\n\nThe `scheduled_test` package defines its own [setUp] method that works just\nlike the one in `unittest`. Tasks can be scheduled in [setUp]; they'll be\nrun before the tasks scheduled by tests in that group. [currentSchedule] is\nalso set in the [setUp] callback.\n\nThis package doesn't have an explicit `tearDown` method. Instead, the\n[currentSchedule.onComplete] and [currentSchedule.onException] task queues\ncan have tasks scheduled during [setUp]. For example:\n\n    import 'package:scheduled_test/scheduled_test.dart';\n\n    void main() {\n      var tempDir;\n      setUp(() {\n        schedule(() {\n          return createTempDir().then((dir) {\n            tempDir = dir;\n          });\n        });\n\n        currentSchedule.onComplete.schedule(() => deleteDir(tempDir));\n      });\n\n      // ...\n    }\n\n## Passing Values Between Tasks\n\nIt's often useful to use values computed in one task in other tasks that are\nscheduled afterwards. There are two ways to do this. The most\nstraightforward is just to define a local variable and assign to it. For\nexample:\n\n    import 'package:scheduled_test/scheduled_test.dart';\n\n    void main() {\n      test('computeValue returns 12', () {\n        var value;\n\n        schedule(() {\n          return computeValue().then((computedValue) {\n            value = computedValue;\n          });\n        });\n\n        schedule(() => expect(value, equals(12)));\n      });\n    }\n\nHowever, this doesn't scale well, especially when you start factoring out\ncalls to [schedule] into library methods. For that reason, [schedule]\nreturns a [Future] that will complete to the same value as the return\nvalue of the task. For example:\n\n    import 'package:scheduled_test/scheduled_test.dart';\n\n    void main() {\n      test('computeValue returns 12', () {\n        var valueFuture = schedule(() => computeValue());\n        schedule(() {\n          valueFuture.then((value) => expect(value, equals(12)));\n        });\n      });\n    }\n\n## Out-of-Band Callbacks\n\nSometimes your tests will have callbacks that don't fit into the schedule.\nIt's important that errors in these callbacks are still registered, though,\nand that [Schedule.onException] and [Schedule.onComplete] still run after\nthey finish. When using `unittest`, you wrap these callbacks with\n`expectAsyncN`; when using `scheduled_test`, you use [wrapAsync] or\n[wrapFuture].\n\n[wrapAsync] has two important functions. First, any errors that occur in it\nwill be passed into the [Schedule] instead of causing the whole test to\ncrash. They can then be handled by [Schedule.onException] and\n[Schedule.onComplete]. Second, a task queue isn't considered finished until\nall of its [wrapAsync]-wrapped functions have been called. This ensures that\n[Schedule.onException] and [Schedule.onComplete] will always run after all\nthe test code in the main queue.\n\nNote that the [completes], [completion], and [throws] matchers use\n[wrapAsync] internally, so they're safe to use in conjunction with scheduled\ntests.\n\nHere's an example of a test using [wrapAsync] to catch errors thrown in the\ncallback of a fictional `startServer` function:\n\n    import 'package:scheduled_test/scheduled_test.dart';\n\n    void main() {\n      test('sendRequest sends a request', () {\n        startServer(wrapAsync((request) {\n          expect(request.body, equals('payload'));\n          request.response.close();\n        }));\n\n        schedule(() => sendRequest('payload'));\n      });\n    }\n\n[wrapFuture] works similarly to [wrapAsync], but instead of wrapping a\nsingle callback it wraps a whole [Future] chain. Like [wrapAsync], it\nensures that the task queue doesn't complete until the out-of-band chain has\nfinished, and that any errors in the chain are piped back into the scheduled\ntest. For example:\n\n    import 'package:scheduled_test/scheduled_test.dart';\n\n    void main() {\n      test('sendRequest sends a request', () {\n        wrapFuture(server.nextRequest.then((request) {\n          expect(request.body, equals('payload'));\n          expect(request.headers['content-type'], equals('text/plain'));\n        }));\n\n        schedule(() => sendRequest('payload'));\n      });\n    }\n\n## Timeouts\n\n`scheduled_test` has a built-in timeout of 30 seconds (configurable via\n[Schedule.timeout]). This timeout is aware of the structure of the schedule;\nthis means that it will reset for each task in a queue, when moving between\nqueues, or almost any other sort of interaction with [currentSchedule]. As\nlong as the [Schedule] knows your test is making some sort of progress, it\nwon't time out.\n\nIf a single task might take a long time, you can also manually tell the\n[Schedule] that it's making progress by calling [Schedule.heartbeat], which\nwill reset the timeout whenever it's called.","line":"174"}