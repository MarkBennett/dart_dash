        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>unittest Library / Dart API Reference</title>
        <link rel="stylesheet" type="text/css"
            href="styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="favicon.ico">
        
        <link rel="stylesheet" type="text/css"
            href="apidoc-styles.css" />
        
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(["_setAccount", "UA-26406144-9"]);
          _gaq.push(["_trackPageview"]);

          (function() {
            var ga = document.createElement("script");
            ga.type = "text/javascript"; ga.async = true;
            ga.src = ("https:" == document.location.protocol ?
              "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(ga, s);
          })();
        </script>
        
        </head>
        <body data-library="unittest">
        <div class="page">
        <div class="header">
          <a href="http://dartlang.org" ref="external"><div class="logo"></div></a>
          <a href="index.html">Dart API Reference</a>
         &rsaquo; <a href="unittest.html">unittest</a>        <form action="http://www.dartlang.org/search.html" id="search-box">
          <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
          <input type="hidden" name="ie" value="UTF-8">
          <input type="hidden" name="hl" value="en">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </form>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="args.html">args</a></h2><h2><div class="icon-library"></div><a href="dart_async.html">dart:async</a></h2><h2><div class="icon-library"></div><a href="dart_chrome.html">dart:chrome</a></h2><h2><div class="icon-library"></div><a href="dart_collection.html">dart:collection</a></h2><h2><div class="icon-library"></div><a href="dart_core.html">dart:core</a></h2><h2><div class="icon-library"></div><a href="dart_crypto.html">dart:crypto</a></h2><h2><div class="icon-library"></div><a href="dart_html.html">dart:html</a></h2><h2><div class="icon-library"></div><a href="dart_indexed_db.html">dart:indexed_db</a></h2><h2><div class="icon-library"></div><a href="dart_io.html">dart:io</a></h2><h2><div class="icon-library"></div><a href="dart_isolate.html">dart:isolate</a></h2><h2><div class="icon-library"></div><a href="dart_json.html">dart:json</a></h2><h2><div class="icon-library"></div><a href="dart_math.html">dart:math</a></h2><h2><div class="icon-library"></div><a href="dart_mirrors.html">dart:mirrors</a></h2><h2><div class="icon-library"></div><a href="dart_scalarlist.html">dart:scalarlist</a></h2><h2><div class="icon-library"></div><a href="dart_svg.html">dart:svg</a></h2><h2><div class="icon-library"></div><a href="dart_uri.html">dart:uri</a></h2><h2><div class="icon-library"></div><a href="dart_utf.html">dart:utf</a></h2><h2><div class="icon-library"></div><a href="dart_web_audio.html">dart:web_audio</a></h2><h2><div class="icon-library"></div><a href="dart_web_sql.html">dart:web_sql</a></h2><h2><div class="icon-library"></div><a href="fixnum.html">fixnum</a></h2><h2><div class="icon-library"></div><a href="intl.html">intl</a></h2><h2><div class="icon-library"></div><a href="logging.html">logging</a></h2><h2><div class="icon-library"></div><a href="matcher.html">matcher</a></h2><h2><div class="icon-library"></div><a href="meta.html">meta</a></h2><h2><div class="icon-library"></div><a href="mock.html">mock</a></h2><h2><div class="icon-library"></div><a href="scheduled_test.html">scheduled_test</a></h2><h2><div class="icon-library"></div><a href="serialization.html">serialization</a></h2><h2><div class="icon-library"></div><strong>unittest</strong></h2><ul class="icon">
<li><a href="unittest/Configuration.html"><div class="icon-class"></div>Configuration</a></li>
<li><a href="unittest/TestCase.html"><div class="icon-class"></div>TestCase</a></li>
<li><a href="unittest/TestFunction.html"><div class="icon-interface"></div>TestFunction</a></li>
</ul>
</div>
<div class="content">
<h2><strong>unittest</strong> library</h2>
<div class="doc"><p>A library for writing dart unit tests.</p>
<p>To import this library, use the pub package manager.
Create a pubspec.yaml file in your project and add
a dependency on unittest with the following lines:</p>
<pre><code>dependencies:
  unittest: any
</code></pre>
<p>Then run 'pub install' from your project directory or using
the DartEditor.</p>
<p>Please see <a href="http://pub.dartlang.org/doc">Pub Getting Started</a>
for more details about the pub package manager.</p>
<h2>Concepts</h2><ul><li>
<p>Tests: Tests are specified via the top-level function <a class="crossref" href="unittest.html#test">test</a>, they can be
   organized together using <a class="crossref" href="unittest.html#group">group</a>.</p></li><li>Checks: Test expectations can be specified via <code>expect</code></li><li>Matchers: <code>expect</code> assertions are written declaratively using <code>Matcher</code>s</li><li>
<p>Configuration: The framework can be adapted by calling <a class="crossref" href="unittest.html#configure">configure</a> with a
   <a class="crossref" href="unittest/Configuration.html">Configuration</a>.  Common configurations can be found in this package
   under: 'dom\<em>config.dart' (deprecated), 'html\</em>config.dart' (for running
   tests compiled to Javascript in a browser), and 'vm\_config.dart' (for
   running native Dart tests on the VM).</p></li></ul>
<h2>Examples</h2>
<p>A trivial test:</p>
<pre><code>import 'package:unittest/unittest.dart';
main() {
  test('this is a test', () {
    int x = 2 + 3;
    expect(x, equals(5));
  });
}
</code></pre>
<p>Multiple tests:</p>
<pre><code>import 'package:unittest/unittest.dart';
main() {
  test('this is a test', () {
    int x = 2 + 3;
    expect(x, equals(5));
  });
  test('this is another test', () {
    int x = 2 + 3;
    expect(x, equals(5));
  });
}
</code></pre>
<p>Multiple tests, grouped by category:</p>
<pre><code>import 'package:unittest/unittest.dart';
main() {
  group('group A', () {
    test('test A.1', () {
      int x = 2 + 3;
      expect(x, equals(5));
    });
    test('test A.2', () {
      int x = 2 + 3;
      expect(x, equals(5));
    });
  });
  group('group B', () {
    test('this B.1', () {
      int x = 2 + 3;
      expect(x, equals(5));
    });
  });
}
</code></pre>
<p>Asynchronous tests: if callbacks expect between 0 and 2 positional arguments,
depending on the suffix of expectAsyncX(). expectAsyncX() will wrap a
function into a new callback and will not consider the test complete until
that callback is run. A count argument can be provided to specify the number
of times the callback should be called (the default is 1).</p>
<pre><code>import 'package:unittest/unittest.dart';
import 'dart:isolate';
main() {
  test('callback is executed once', () {
    // wrap the callback of an asynchronous call with [expectAsync0] if
    // the callback takes 0 arguments...
    var timer = Timer.run(expectAsync0(() {
      int x = 2 + 3;
      expect(x, equals(5));
    }));
  });

  test('callback is executed twice', () {
    var callback = expectAsync0(() {
      int x = 2 + 3;
      expect(x, equals(5));
    }, count: 2); // &lt;-- we can indicate multiplicity to [expectAsync0]
    Timer.run(callback);
    Timer.run(callback);
  });
}
</code></pre>
<p>expectAsyncX() will wrap the callback code in a try/catch handler to handle
exceptions (treated as test failures). There may be times when the number of
times a callback should be called is non-deterministic. In this case a dummy
callback can be created with expectAsync0((){}) and this can be called from
the real callback when it is finally complete. In this case the body of the
callback should be protected within a call to guardAsync(); this will ensure
that exceptions are properly handled.</p>
<p>Note: due to some language limitations we have to use different functions
depending on the number of positional arguments of the callback. In the
future, we plan to expose a single <code>expectAsync</code> function that can be used
regardless of the number of positional arguments. This requires new langauge
features or fixes to the current spec (e.g. see
<a href="http://dartbug.com/2706">Issue 2706</a>).</p>
<p>Meanwhile, we plan to add this alternative API for callbacks of more than 2
arguments or that take named parameters. (this is not implemented yet,
but will be coming here soon).</p>
<pre><code>import 'package:unittest/unittest.dart';
import 'dart:isolate';
main() {
  test('callback is executed', () {
    // indicate ahead of time that an async callback is expected.
    var async = startAsync();
    Timer.run(() {
      // Guard the body of the callback, so errors are propagated
      // correctly.
      guardAsync(() {
        int x = 2 + 3;
        expect(x, equals(5));
      });
      // indicate that the asynchronous callback was invoked.
      async.complete();
    });
  });
}
</code></pre></div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="config">
<button class="show-code">Code</button>
final <a href="unittest/Configuration.html">Configuration</a>         <strong>config</strong> <a class="anchor-link"
            href="#config"
            title="Permalink to config">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Configuration get config =&gt; _config;
</pre>
</div>
</div>
<div class="field"><h4 id="ERROR">
<button class="show-code">Code</button>
const         <strong>ERROR</strong> <a class="anchor-link"
            href="#ERROR"
            title="Permalink to ERROR">#</a>
        </h4>
        <div class="doc">
<pre class="source">
ERROR = 'error'
</pre>
</div>
</div>
<div class="field"><h4 id="FAIL">
<button class="show-code">Code</button>
const         <strong>FAIL</strong> <a class="anchor-link"
            href="#FAIL"
            title="Permalink to FAIL">#</a>
        </h4>
        <div class="doc">
<pre class="source">
FAIL  = 'fail'
</pre>
</div>
</div>
<div class="field"><h4 id="groupSep">
<button class="show-code">Code</button>
<a href="dart_core/String.html">String</a>         <strong>groupSep</strong> <a class="anchor-link"
            href="#groupSep"
            title="Permalink to groupSep">#</a>
        </h4>
        <div class="doc">
<pre class="source">
groupSep = ' '
</pre>
</div>
</div>
<div class="field"><h4 id="PASS">
<button class="show-code">Code</button>
const         <strong>PASS</strong> <a class="anchor-link"
            href="#PASS"
            title="Permalink to PASS">#</a>
        </h4>
        <div class="doc">
<pre class="source">
PASS  = 'pass'
</pre>
</div>
</div>
<div class="field"><h4 id="testCases">
<button class="show-code">Code</button>
final         <strong>testCases</strong> <a class="anchor-link"
            href="#testCases"
            title="Permalink to testCases">#</a>
        </h4>
        <div class="doc">
<p>Get the list of tests. </p>
<pre class="source">
get testCases =&gt; _tests;
</pre>
</div>
</div>
<div class="field"><h4 id="testState">
<button class="show-code">Code</button>
<a href="dart_core/Map.html">Map</a>         <strong>testState</strong> <a class="anchor-link"
            href="#testState"
            title="Permalink to testState">#</a>
        </h4>
        <div class="doc">
<pre class="source">
testState = {}
</pre>
</div>
</div>
</div>
<div>
<h3>Functions</h3>
<div class="method"><h4 id="disableTest">
<button class="show-code">Code</button>
void <strong>disableTest</strong>(<a href="dart_core/int.html">int</a> testId) <a class="anchor-link" href="#disableTest"
              title="Permalink to disableTest">#</a></h4>
<div class="doc">
<p>Disable a test by ID. </p>
<pre class="source">
void disableTest(int testId) =&gt; _setTestEnabledState(testId, false);
</pre>
</div>
</div>
<div class="method"><h4 id="enableTest">
<button class="show-code">Code</button>
void <strong>enableTest</strong>(<a href="dart_core/int.html">int</a> testId) <a class="anchor-link" href="#enableTest"
              title="Permalink to enableTest">#</a></h4>
<div class="doc">
<p>Enable a test by ID. </p>
<pre class="source">
void enableTest(int testId) =&gt; _setTestEnabledState(testId, true);
</pre>
</div>
</div>
<div class="method"><h4 id="setSoloTest">
<button class="show-code">Code</button>
void <strong>setSoloTest</strong>(<a href="dart_core/int.html">int</a> id) <a class="anchor-link" href="#setSoloTest"
              title="Permalink to setSoloTest">#</a></h4>
<div class="doc">
<p>Select a solo test by ID. </p>
<pre class="source">
void setSoloTest(int id) {
 for (var i = 0; i &lt; _tests.length; i++) {
   if (_tests[i].id == id) {
     _soloTest = _tests[i];
     break;
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="ensureInitialized">
<button class="show-code">Code</button>
<strong>ensureInitialized</strong>() <a class="anchor-link" href="#ensureInitialized"
              title="Permalink to ensureInitialized">#</a></h4>
<div class="doc">
<p>Lazily initializes the test library if not already initialized.</p>
<pre class="source">
ensureInitialized() {
 if (_initialized) {
   return;
 }
 _initialized = true;
 // Hook our async guard into the matcher library.
 wrapAsync = expectAsync1;

 _tests = &lt;TestCase&gt;[];
 _testRunner = _nextBatch;
 _uncaughtErrorMessage = null;

 if (_config == null) {
   _config = new Configuration();
 }
 _config.onInit();

 if (_config.autoStart) {
   // Immediately queue the suite up. It will run after a timeout (i.e. after
   // main() has returned).
   _defer(runTests);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="fail">
<button class="show-code">Code</button>
void <strong>fail</strong>(<a href="dart_core/String.html">String</a> message) <a class="anchor-link" href="#fail"
              title="Permalink to fail">#</a></h4>
<div class="doc">
<pre class="source">
void fail(String message) {
 throw new ExpectException(message);
}
</pre>
</div>
</div>
<div class="method"><h4 id="registerException">
<button class="show-code">Code</button>
<strong>registerException</strong>(e, [trace]) <a class="anchor-link" href="#registerException"
              title="Permalink to registerException">#</a></h4>
<div class="doc">
<p>Registers that an exception was caught for the current test.</p>
<pre class="source">
registerException(e, [trace]) {
 _registerException(_currentTest, e, trace);
}
</pre>
</div>
</div>
<div class="method"><h4 id="guardAsync">
<button class="show-code">Code</button>
<strong>guardAsync</strong>(tryBody, [finallyBody, testNum = -1]) <a class="anchor-link" href="#guardAsync"
              title="Permalink to guardAsync">#</a></h4>
<div class="doc">
<p>Run 
<span class="param">tryBody</span> guarded in a try-catch block. If an exception is thrown, update
the <a class="crossref" href="unittest.html#_currentTest">_currentTest</a> status accordingly.</p>
<pre class="source">
guardAsync(tryBody, [finallyBody, testNum = -1]) {
 if (testNum &lt; 0) testNum = _currentTest;
 try {
   return tryBody();
 } catch (e, trace) {
   _registerException(testNum, e, trace);
 } finally {
   if (finallyBody != null) finallyBody();
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="runTests">
<button class="show-code">Code</button>
<strong>runTests</strong>() <a class="anchor-link" href="#runTests"
              title="Permalink to runTests">#</a></h4>
<div class="doc">
<p>Runs all queued tests, one at a time. </p>
<pre class="source">
runTests() {
 _currentTest = 0;
 _currentGroup = '';

 // If we are soloing a test, remove all the others.
 if (_soloTest != null) {
   filterTests((t) =&gt; t == _soloTest);
 }

 _config.onStart();

 _defer(() {
   _testRunner();
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="filterTests">
<button class="show-code">Code</button>
void <strong>filterTests</strong>(testFilter) <a class="anchor-link" href="#filterTests"
              title="Permalink to filterTests">#</a></h4>
<div class="doc">
<p>Filter the tests. 
<span class="param">testFilter</span> can be a <code>RegExp</code>, a <code>String</code> or a
predicate function. This is different to enabling/disabling tests
in that it removes the tests completely.</p>
<pre class="source">
void filterTests(testFilter) {
 var filterFunction;
 if (testFilter is String) {
   RegExp re = new RegExp(testFilter);
   filterFunction = (t) =&gt; re.hasMatch(t.description);
 } else if (testFilter is RegExp) {
   filterFunction = (t) =&gt; testFilter.hasMatch(t.description);
 } else if (testFilter is Function) {
   filterFunction = testFilter;
 }
 _tests = _tests.where(filterFunction).toList();
}
</pre>
</div>
</div>
<div class="method"><h4 id="rerunTests">
<button class="show-code">Code</button>
<strong>rerunTests</strong>() <a class="anchor-link" href="#rerunTests"
              title="Permalink to rerunTests">#</a></h4>
<div class="doc">
<pre class="source">
rerunTests() {
 _uncaughtErrorMessage = null;
 _initialized = true; // We don't want to reset the test array.
 runTests();
}
</pre>
</div>
</div>
<div class="method"><h4 id="callbackDone">
<button class="show-code">Code</button>
void <strong>callbackDone</strong>() <a class="anchor-link" href="#callbackDone"
              title="Permalink to callbackDone">#</a></h4>
<div class="doc">
<p>Temporary hack: expose old API.
TODO(gram) remove this when WebKit tests are working with new framework</p>
<pre class="source">
void callbackDone() {
 _handleCallbackFunctionComplete(_currentTest);
}
</pre>
</div>
</div>
<div class="method"><h4 id="tearDown">
<button class="show-code">Code</button>
void <strong>tearDown</strong>(<a href="dart_core/Function.html">Function</a> teardownTest) <a class="anchor-link" href="#tearDown"
              title="Permalink to tearDown">#</a></h4>
<div class="doc">
<p>Register a <a class="crossref" href="unittest.html#tearDown">tearDown</a> function for a test <a class="crossref" href="unittest.html#group">group</a>. This function will
be called after each test in the group is run. Note that if groups
are nested only the most locally scoped 
<span class="param">teardownTest</span> function will be run.
<a class="crossref" href="unittest.html#setUp">setUp</a> and <a class="crossref" href="unittest.html#tearDown">tearDown</a> should be called within the <a class="crossref" href="unittest.html#group">group</a> before any
calls to <a class="crossref" href="unittest.html#test">test</a>. The 
<span class="param">teardownTest</span> function can be asynchronous; in this
case it must return a <code>Future</code>.</p>
<pre class="source">
void tearDown(Function teardownTest) {
 _testTeardown = teardownTest;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setUp">
<button class="show-code">Code</button>
void <strong>setUp</strong>(<a href="dart_core/Function.html">Function</a> setupTest) <a class="anchor-link" href="#setUp"
              title="Permalink to setUp">#</a></h4>
<div class="doc">
<p>Register a <a class="crossref" href="unittest.html#setUp">setUp</a> function for a test <a class="crossref" href="unittest.html#group">group</a>. This function will
be called before each test in the group is run. Note that if groups
are nested only the most locally scoped <code>setUpTest</code> function will be run.
<a class="crossref" href="unittest.html#setUp">setUp</a> and <a class="crossref" href="unittest.html#tearDown">tearDown</a> should be called within the <a class="crossref" href="unittest.html#group">group</a> before any
calls to <a class="crossref" href="unittest.html#test">test</a>. The 
<span class="param">setupTest</span> function can be asynchronous; in this
case it must return a <code>Future</code>.</p>
<pre class="source">
void setUp(Function setupTest) {
 _testSetup = setupTest;
}
</pre>
</div>
</div>
<div class="method"><h4 id="group">
<button class="show-code">Code</button>
void <strong>group</strong>(<a href="dart_core/String.html">String</a> description, void body()) <a class="anchor-link" href="#group"
              title="Permalink to group">#</a></h4>
<div class="doc">
<p>Creates a new named group of tests. Calls to group() or test() within the
body of the function passed to this will inherit this group's description.</p>
<pre class="source">
void group(String description, void body()) {
 ensureInitialized();
 // Concatenate the new group.
 final parentGroup = _currentGroup;
 if (_currentGroup != '') {
   // Add a space.
   _currentGroup = '$_currentGroup$groupSep$description';
 } else {
   // The first group.
   _currentGroup = description;
 }

 // Groups can be nested, so we need to preserve the current
 // settings for test setup/teardown.
 Function parentSetup = _testSetup;
 Function parentTeardown = _testTeardown;

 try {
   _testSetup = null;
   _testTeardown = null;
   body();
 } catch (e, trace) {
   var stack = (trace == null) ? '' : ': ${trace.toString()}';
   _uncaughtErrorMessage = "${e.toString()}$stack";
 } finally {
   // Now that the group is over, restore the previous one.
   _currentGroup = parentGroup;
   _testSetup = parentSetup;
   _testTeardown = parentTeardown;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="protectAsync2">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>protectAsync2</strong>(<a href="dart_core/Function.html">Function</a> callback) <a class="anchor-link" href="#protectAsync2"
              title="Permalink to protectAsync2">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#protectAsync0">protectAsync0</a> but 
<span class="param">callback</span> should take 2 positional arguments.</p>
<pre class="source">
Function protectAsync2(Function callback) {
 return new _SpreadArgsHelper.optionalCalls(callback).invoke2;
}
</pre>
</div>
</div>
<div class="method"><h4 id="protectAsync1">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>protectAsync1</strong>(<a href="dart_core/Function.html">Function</a> callback) <a class="anchor-link" href="#protectAsync1"
              title="Permalink to protectAsync1">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#protectAsync0">protectAsync0</a> but 
<span class="param">callback</span> should take 1 positional argument.</p>
<pre class="source">
Function protectAsync1(Function callback) {
 return new _SpreadArgsHelper.optionalCalls(callback).invoke1;
}
</pre>
</div>
</div>
<div class="method"><h4 id="protectAsync0">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>protectAsync0</strong>(<a href="dart_core/Function.html">Function</a> callback) <a class="anchor-link" href="#protectAsync0"
              title="Permalink to protectAsync0">#</a></h4>
<div class="doc">
<p>Wraps the 
<span class="param">callback</span> in a new function and returns that function. The new
function will be able to handle exceptions by directing them to the correct
test. This is thus similar to expectAsync0. Use it to wrap any callbacks that
might optionally be called but may never be called during the test.

<span class="param">callback</span> should take 0 positional arguments (named arguments are not
supported).</p>
<pre class="source">
Function protectAsync0(Function callback) {
 return new _SpreadArgsHelper.optionalCalls(callback).invoke0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsyncUntil2">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>expectAsyncUntil2</strong>(<a href="dart_core/Function.html">Function</a> callback, <a href="dart_core/Function.html">Function</a> isDone) <a class="anchor-link" href="#expectAsyncUntil2"
              title="Permalink to expectAsyncUntil2">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#expectAsyncUntil0">expectAsyncUntil0</a> but 
<span class="param">callback</span> should take 2 positional arguments.</p>
<pre class="source">
Function expectAsyncUntil2(Function callback, Function isDone) {
 return new _SpreadArgsHelper.variableCallCount(callback, isDone).invoke2;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsyncUntil1">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>expectAsyncUntil1</strong>(<a href="dart_core/Function.html">Function</a> callback, <a href="dart_core/Function.html">Function</a> isDone) <a class="anchor-link" href="#expectAsyncUntil1"
              title="Permalink to expectAsyncUntil1">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#expectAsyncUntil0">expectAsyncUntil0</a> but 
<span class="param">callback</span> should take 1 positional argument.</p>
<pre class="source">
Function expectAsyncUntil1(Function callback, Function isDone) {
 return new _SpreadArgsHelper.variableCallCount(callback, isDone).invoke1;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsyncUntil0">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>expectAsyncUntil0</strong>(<a href="dart_core/Function.html">Function</a> callback, <a href="dart_core/Function.html">Function</a> isDone) <a class="anchor-link" href="#expectAsyncUntil0"
              title="Permalink to expectAsyncUntil0">#</a></h4>
<div class="doc">
<p>Indicate that 
<span class="param">callback</span> is expected to be called until 
<span class="param">isDone</span> returns
true. The unittest framework check 
<span class="param">isDone</span> after each callback and only
when it returns true will it continue with the following test. Using
<a class="crossref" href="unittest.html#expectAsyncUntil0">expectAsyncUntil0</a> will also ensure that errors that occur within

<span class="param">callback</span> are tracked and reported. 
<span class="param">callback</span> should take 0 positional
arguments (named arguments are not supported).</p>
<pre class="source">
Function expectAsyncUntil0(Function callback, Function isDone) {
 return new _SpreadArgsHelper.variableCallCount(callback, isDone).invoke0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsync2">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>expectAsync2</strong>(<a href="dart_core/Function.html">Function</a> callback, {<a href="dart_core/int.html">int</a> count: 1, <a href="dart_core/String.html">String</a> id}) <a class="anchor-link" href="#expectAsync2"
              title="Permalink to expectAsync2">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#expectAsync0">expectAsync0</a> but 
<span class="param">callback</span> should take 2 positional arguments. </p>
<pre class="source">
Function expectAsync2(Function callback, {int count: 1, String id}) {
 return new _SpreadArgsHelper.
     fixedCallCount(callback, count, id).invoke2;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsync1">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>expectAsync1</strong>(<a href="dart_core/Function.html">Function</a> callback, {<a href="dart_core/int.html">int</a> count: 1, <a href="dart_core/String.html">String</a> id}) <a class="anchor-link" href="#expectAsync1"
              title="Permalink to expectAsync1">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#expectAsync0">expectAsync0</a> but 
<span class="param">callback</span> should take 1 positional argument. </p>
<pre class="source">
Function expectAsync1(Function callback, {int count: 1, String id}) {
 return new _SpreadArgsHelper.
     fixedCallCount(callback, count, id).invoke1;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsync0">
<button class="show-code">Code</button>
<a href="dart_core/Function.html">Function</a> <strong>expectAsync0</strong>(<a href="dart_core/Function.html">Function</a> callback, {<a href="dart_core/int.html">int</a> count: 1, <a href="dart_core/String.html">String</a> id}) <a class="anchor-link" href="#expectAsync0"
              title="Permalink to expectAsync0">#</a></h4>
<div class="doc">
<p>Indicate that 
<span class="param">callback</span> is expected to be called a 
<span class="param">count</span> number of times
(by default 1). The unittest framework will wait for the callback to run the
specified 
<span class="param">count</span> times before it continues with the following test.  Using
<a class="crossref" href="unittest.html#expectAsync0">expectAsync0</a> will also ensure that errors that occur within 
<span class="param">callback</span> are
tracked and reported. 
<span class="param">callback</span> should take 0 positional arguments (named
arguments are not supported). 
<span class="param">id</span> can be used to provide more
descriptive error messages if the callback is called more often than
expected.</p>
<pre class="source">
Function expectAsync0(Function callback, {int count: 1, String id}) {
 return new _SpreadArgsHelper.
     fixedCallCount(callback, count, id).invoke0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="solo_test">
<button class="show-code">Code</button>
void <strong>solo_test</strong>(<a href="dart_core/String.html">String</a> spec, <a href="unittest/TestFunction.html">TestFunction</a> body) <a class="anchor-link" href="#solo_test"
              title="Permalink to solo_test">#</a></h4>
<div class="doc">
<p>Creates a new test case with the given description and body. The
description will include the descriptions of any surrounding group()
calls.</p>
<p>"solo<em>" means that this will be the only test that is run. All other tests
will be skipped. This is a convenience function to let you quickly isolate
a single test by adding "solo</em>" before it to temporarily disable all other
tests.</p>
<pre class="source">
void solo_test(String spec, TestFunction body) {
 // TODO(rnystrom): Support multiple solos. If more than one test is solo-ed,
 // all of the solo-ed tests and none of the non-solo-ed ones should run.
 if (_soloTest != null) {
   throw new Exception('Only one test can be soloed right now.');
 }

 ensureInitialized();

 _soloTest = new TestCase(_tests.length + 1, _fullSpec(spec), body, 0);
 _tests.add(_soloTest);
}
</pre>
</div>
</div>
<div class="method"><h4 id="test">
<button class="show-code">Code</button>
void <strong>test</strong>(<a href="dart_core/String.html">String</a> spec, <a href="unittest/TestFunction.html">TestFunction</a> body) <a class="anchor-link" href="#test"
              title="Permalink to test">#</a></h4>
<div class="doc">
<p>Creates a new test case with the given description and body. The
description will include the descriptions of any surrounding group()
calls.</p>
<pre class="source">
void test(String spec, TestFunction body) {
 ensureInitialized();
 _tests.add(new TestCase(_tests.length + 1, _fullSpec(spec), body, 0));
}
</pre>
</div>
</div>
<div class="method"><h4 id="logMessage">
<button class="show-code">Code</button>
void <strong>logMessage</strong>(<a href="dart_core/String.html">String</a> message) <a class="anchor-link" href="#logMessage"
              title="Permalink to logMessage">#</a></h4>
<div class="doc">
<pre class="source">
void logMessage(String message) =&gt; _config.logMessage(message);
</pre>
</div>
</div>
<div class="method"><h4 id="configure">
<button class="show-code">Code</button>
<a href="unittest/Configuration.html">Configuration</a> <strong>configure</strong>(<a href="unittest/Configuration.html">Configuration</a> config) <a class="anchor-link" href="#configure"
              title="Permalink to configure">#</a></h4>
<div class="doc">
<p>Set the <a class="crossref" href="unittest/Configuration.html">Configuration</a> used by the unittest library. Returns any
previous configuration.
TODO: consider deprecating in favor of a setter now we have a getter.</p>
<pre class="source">
Configuration configure(Configuration config) {
 Configuration _oldConfig = _config;
 _config = config;
 return _oldConfig;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Classes</h3>
          <div class="type">
          <h4>
            <a href="unittest/Configuration.html"><strong>Configuration</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="unittest/TestCase.html"><strong>TestCase</strong></a>
          </h4>
          </div>
          
</div>
<div>
<h3>Typedefs</h3>
          <div class="type">
          <h4>
            <a href="unittest/TestFunction.html"><strong>TestFunction</strong></a>
          </h4>
          </div>
          
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-02-26 14:53:07.852</div>
<div>        <p>Except as otherwise <a href="http://code.google.com/policies.html#restrictions">noted</a>, the content of this
        page is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution
        3.0 License</a>, and code samples are licensed under the
        <a href="http://code.google.com/google_bsd_license.html">BSD License</a>.</p>
        <p><a href="http://www.dartlang.org/tos.html">Terms of Service</a> |
        <a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a></p>
        </div>
        </div>
        <script async src="client-static.js"></script>
        </body></html>
        
