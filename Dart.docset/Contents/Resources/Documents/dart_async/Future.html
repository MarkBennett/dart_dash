        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Future&lt;T&gt; abstract class / dart:async Library / Dart API Reference</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        <link rel="stylesheet" type="text/css"
            href="../apidoc-styles.css" />
        
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(["_setAccount", "UA-26406144-9"]);
          _gaq.push(["_trackPageview"]);

          (function() {
            var ga = document.createElement("script");
            ga.type = "text/javascript"; ga.async = true;
            ga.src = ("https:" == document.location.protocol ?
              "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(ga, s);
          })();
        </script>
        
        </head>
        <body data-library="dart:async" data-type="Future&amp;lt;T&amp;gt;">
        <div class="page">
        <div class="header">
          <a href="http://dartlang.org" ref="external"><div class="logo"></div></a>
          <a href="../index.html">Dart API Reference</a>
         &rsaquo; <a href="../dart_async.html">dart:async</a> &rsaquo; <a href="../dart_async/Future.html">Future&lt;T&gt;</a>        <form action="http://www.dartlang.org/search.html" id="search-box">
          <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
          <input type="hidden" name="ie" value="UTF-8">
          <input type="hidden" name="hl" value="en">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </form>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../args.html">args</a></h2><h2><div class="icon-library"></div><a href="../dart_async.html">dart:async</a></h2><ul class="icon">
<li><a href="../dart_async/CollectionSink.html"><div class="icon-class"></div>CollectionSink&lt;T&gt;</a></li>
<li><a href="../dart_async/Completer.html"><div class="icon-class"></div>Completer&lt;T&gt;</a></li>
<li><a href="../dart_async/DeferredLibrary.html"><div class="icon-class"></div>DeferredLibrary</a></li>
<li><a href="../dart_async/EventTransformStream.html"><div class="icon-class"></div>EventTransformStream&lt;S, T&gt;</a></li>
<li><div class="icon-class"></div><strong>Future&lt;T&gt;</strong></li>
<li><a href="../dart_async/Stream.html"><div class="icon-class"></div>Stream&lt;T&gt;</a></li>
<li><a href="../dart_async/StreamConsumer.html"><div class="icon-class"></div>StreamConsumer&lt;S, T&gt;</a></li>
<li><a href="../dart_async/StreamController.html"><div class="icon-class"></div>StreamController&lt;T&gt;</a></li>
<li><a href="../dart_async/StreamEventTransformer.html"><div class="icon-class"></div>StreamEventTransformer&lt;S, T&gt;</a></li>
<li><a href="../dart_async/StreamSink.html"><div class="icon-class"></div>StreamSink&lt;T&gt;</a></li>
<li><a href="../dart_async/StreamSinkView.html"><div class="icon-class"></div>StreamSinkView&lt;T&gt;</a></li>
<li><a href="../dart_async/StreamSubscription.html"><div class="icon-class"></div>StreamSubscription&lt;T&gt;</a></li>
<li><a href="../dart_async/StreamTransformer.html"><div class="icon-class"></div>StreamTransformer&lt;S, T&gt;</a></li>
<li><a href="../dart_async/StreamView.html"><div class="icon-class"></div>StreamView&lt;T&gt;</a></li>
<li><a href="../dart_async/Timer.html"><div class="icon-class"></div>Timer</a></li>
<li><a href="../dart_async/AsyncError.html"><div class="icon-exception"></div>AsyncError</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../dart_chrome.html">dart:chrome</a></h2><h2><div class="icon-library"></div><a href="../dart_collection.html">dart:collection</a></h2><h2><div class="icon-library"></div><a href="../dart_core.html">dart:core</a></h2><h2><div class="icon-library"></div><a href="../dart_crypto.html">dart:crypto</a></h2><h2><div class="icon-library"></div><a href="../dart_html.html">dart:html</a></h2><h2><div class="icon-library"></div><a href="../dart_indexed_db.html">dart:indexed_db</a></h2><h2><div class="icon-library"></div><a href="../dart_io.html">dart:io</a></h2><h2><div class="icon-library"></div><a href="../dart_isolate.html">dart:isolate</a></h2><h2><div class="icon-library"></div><a href="../dart_json.html">dart:json</a></h2><h2><div class="icon-library"></div><a href="../dart_math.html">dart:math</a></h2><h2><div class="icon-library"></div><a href="../dart_mirrors.html">dart:mirrors</a></h2><h2><div class="icon-library"></div><a href="../dart_scalarlist.html">dart:scalarlist</a></h2><h2><div class="icon-library"></div><a href="../dart_svg.html">dart:svg</a></h2><h2><div class="icon-library"></div><a href="../dart_uri.html">dart:uri</a></h2><h2><div class="icon-library"></div><a href="../dart_utf.html">dart:utf</a></h2><h2><div class="icon-library"></div><a href="../dart_web_audio.html">dart:web_audio</a></h2><h2><div class="icon-library"></div><a href="../dart_web_sql.html">dart:web_sql</a></h2><h2><div class="icon-library"></div><a href="../fixnum.html">fixnum</a></h2><h2><div class="icon-library"></div><a href="../intl.html">intl</a></h2><h2><div class="icon-library"></div><a href="../logging.html">logging</a></h2><h2><div class="icon-library"></div><a href="../matcher.html">matcher</a></h2><h2><div class="icon-library"></div><a href="../meta.html">meta</a></h2><h2><div class="icon-library"></div><a href="../mock.html">mock</a></h2><h2><div class="icon-library"></div><a href="../scheduled_test.html">scheduled_test</a></h2><h2><div class="icon-library"></div><a href="../serialization.html">serialization</a></h2><h2><div class="icon-library"></div><a href="../unittest.html">unittest</a></h2></div>
<div class="content">
        <h2><strong>Future&lt;T&gt;</strong>
          abstract class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A <a class="crossref" href="../dart_async/Future.html">Future</a> represents a delayed computation. It is used to obtain a not-yet
available value, or error, sometime in the future.  Receivers of a
<a class="crossref" href="../dart_async/Future.html">Future</a> can register callbacks that handle the value or error once it is
available. For example:</p>
<pre><code>Future&lt;int&gt; future = getFuture();
future.then((value) =&gt; handleValue(value))
      .catchError((error) =&gt; handleError(error));
</code></pre>
<p>A <a class="crossref" href="../dart_async/Future.html">Future</a> can be completed in two ways: with a value ("the future succeeds")
or with an error ("the future fails"). Users can install callbacks for each
case. The result of registering a pair of callbacks is a new Future (the
"successor") which in turn is completed with the result of invoking the
corresponding callback. The successor is completed with an error if the
invoked callback throws. For example:</p>
<pre><code>Future&lt;int&gt; successor = future.then((int value) {
    // Invoked when the future is completed with a value.
    return 42;  // The successor is completed with the value 42.
  },
  onError: (AsyncError e) {
    // Invoked when the future is completed with an error.
    if (canHandle(e)) {
      return 499;  // The successor is completed with the value 499.
    } else {
      throw e;  // The successor is completed with the error e.
    }
  });
</code></pre>
<p>If a future does not have a successor but is completed with an error, it
forwards the error message to the global error-handler. This special casing
makes sure that no error is silently dropped. However, it also means that
error handlers should be installed early, so that they are present as soon
as a future is completed with an error. The following example demonstrates
this potential bug:</p>
<pre><code>var future = getFuture();
new Timer(new Duration(milliseconds: 5), () {
  // The error-handler is only attached 5ms after the future has been
  // received. If the future fails in the mean-time it will forward the
  // error to the global error-handler, even though there is code (just
  // below) to handle the error.
  future.then((value) { useValue(value); },
              onError: (e) { handleError(e); });
});
</code></pre>
<p>In general we discourage registering the two callbacks at the same time, but
prefer to use <a class="crossref" href="../dart_async/Future.html#then">then</a> with one argument (the value handler), and to use
<a class="crossref" href="../dart_async/Future.html#catchError">catchError</a> for handling errors. The missing callbacks (the error-handler
for <a class="crossref" href="../dart_async/Future.html#then">then</a>, and the value-handler for <a class="crossref" href="../dart_async/Future.html#catchError">catchError</a>), are automatically
configured to "forward" the value/error. Separating value and error-handling
into separate registration calls usually leads to code that is easier to
reason about. In fact it makes asynchronous code very similar to synchronous
code:</p>
<pre><code>// Synchronous code.
try {
  int value = foo();
  return bar(value);
} catch (e) {
  return 499;
}
</code></pre>
<p> Equivalent asynchronous code, based on futures:</p>
<pre><code>Future&lt;int&gt; future = foo();  // foo now returns a future.
future.then((int value) =&gt; bar(value))
      .catchError((e) =&gt; 499);
</code></pre>
<p>Similar to the synchronous code, the error handler (registered with
<a class="crossref" href="../dart_async/Future.html#catchError">catchError</a>) is handling the errors for exceptions coming from calls to
'foo', as well as 'bar'. This would not be the case if the error-handler was
registered at the same time as the value-handler.</p>
<p>Futures can have more than one callback-pairs registered. Each successor is
treated independently and is handled as if it was the only successor.</p>
<pre class="source">
abstract class Future&lt;T&gt; {
 /**
  * Creates a future containing the result of calling [function].
  *
  * The result of computing [:function():] is either a returned value or
  * a throw.
  *
  * If a value is returned, it becomes the result of the created future.
  *
  * If calling [function] throws, the created [Future] will be completed
  * with an async error containing the thrown value and a captured
  * stacktrace.
  *
  * However, if the result of calling [function] is already an asynchronous
  * result, we treat it specially.
  *
  * If the returned value is itself a [Future], completion of
  * the created future will wait until the returned future completes,
  * and will then complete with the same result.
  *
  * If a thrown value is an [AsyncError], it is used directly as the result
  * of the created future.
  */
 factory Future.of(function()) {
   try {
     var result = function();
     return new _FutureImpl&lt;T&gt;().._setOrChainValue(result);
   } catch (error, stackTrace) {
     return new _FutureImpl&lt;T&gt;.immediateError(error, stackTrace);
   }
 }

 /**
  * A future whose value is available in the next event-loop iteration.
  *
  * If [value] is not a [Future], using this constructor is equivalent
  * to [:new Future.of(() =&gt; value):].
  *
  * See [Completer] to create a Future and complete it later.
  */
 factory Future.immediate(T value) =&gt; new _FutureImpl&lt;T&gt;.immediate(value);

 /**
  * A future that completes with an error in the next event-loop iteration.
  *
  * See [Completer] to create a Future and complete it later.
  */
 factory Future.immediateError(var error, [Object stackTrace]) {
   return new _FutureImpl&lt;T&gt;.immediateError(error, stackTrace);
 }

 /**
  * Creates a future that completes after a delay.
  *
  * The future will be completed after the given [duration] has passed with
  * the result of calling [computation]. If the duration is 0 or less, it
  * completes no sooner than in the next event-loop iteration.
  *
  * If [computation] is not given or [:null:] then it will behave as if
  * [computation] was set to [:() =&gt; null:]. That is, it will complete with
  * [:null:].
  *
  * If calling [computation] throws, the created future will complete with the
  * error.
  *
  * See [Completer]s, for futures with values that are computed asynchronously.
  *
  * *Deprecation note*: this method initially took an [int] as argument (the
  * milliseconds to wait). It is now a [Duration].
  */
 factory Future.delayed(var duration, [T computation()]) {
   // TODO(floitsch): no need to allocate a ThenFuture when the computation is
   // null.
   if (computation == null) computation = (() =&gt; null);
   _ThenFuture&lt;dynamic, T&gt; future =
       new _ThenFuture&lt;dynamic, T&gt;((_) =&gt; computation());
   new Timer(duration, () =&gt; future._sendValue(null));
   return future;
 }

 /**
  * Wait for all the given futures to complete and collect their values.
  *
  * Returns a future which will complete once all the futures in a list are
  * complete. If any of the futures in the list completes with an error,
  * the resulting future also completes with an error. Otherwise the value
  * of the returned future will be a list of all the values that were produced.
  */
 static Future&lt;List&gt; wait(Iterable&lt;Future&gt; futures) {
   return new _FutureImpl&lt;List&gt;.wait(futures);
 }

 /**
  * Perform an async operation for each element of the iterable, in turn.
  *
  * Runs [f] for each element in [input] in order, moving to the next element
  * only when the [Future] returned by [f] completes. Returns a [Future] that
  * completes when all elements have been processed.
  *
  * The return values of all [Future]s are discarded. Any errors will cause the
  * iteration to stop and will be piped through the returned [Future].
  */
 static Future forEach(Iterable input, Future f(element)) {
   _FutureImpl doneSignal = new _FutureImpl();
   Iterator iterator = input.iterator;
   void nextElement(_) {
     if (iterator.moveNext()) {
       f(iterator.current).then(nextElement, onError: doneSignal._setError);
     } else {
       doneSignal._setValue(null);
     }
   }
   nextElement(null);
   return doneSignal;
 }

 /**
  * When this future completes with a value, then [onValue] is called with this
  * value. If [this] future is already completed then the invocation of
  * [onValue] is delayed until the next event-loop iteration.
  *
  * Returns a new [Future] `f` which is completed with the result of
  * invoking [onValue] (if [this] completes with a value) or [onError] (if
  * [this] completes with an error).
  *
  * If the invoked callback throws an exception, the returned future `f` is
  * completed with the error. If the value thrown is an [AsyncError], it is
  * used directly, as the error result. Otherwise it is wrapped in an
  * [AsyncError] first.
  *
  * If the invoked callback returns a [Future] `f2` then `f` and `f2` are
  * chained. That is, `f` is completed with the completion value of `f2`.
  *
  * If [onError] is not given, it is equivalent to `(e) { throw e; }`. That
  * is, it forwards the error to `f`.
  *
  * In most cases, it is more readable to use [catchError] separately, possibly
  * with a `test` parameter, instead of handling both value and error in a
  * single [then] call.
  */
 Future then(onValue(T value), { onError(AsyncError asyncError) });

 /**
  * Handles errors emitted by this [Future].
  *
  * Returns a new [Future] `f`.
  *
  * When [this] completes with a value, the value is forwarded to `f`
  * unmodified. That is, `f` completes with the same value.
  *
  * When [this] completes with an error, [test] is called with the
  * error's value. If the invocation returns [true], [onError] is called with
  * the error wrapped in an [AsyncError]. The result of [onError] is handled
  * exactly the same as for [then]'s [onError].
  *
  * If [test] returns false, the exception is not handled by [onError], but is
  * thrown unmodified, thus forwarding it to `f`.
  *
  * If [test] is omitted, it defaults to a function that always returns true.
  *
  * Example:
  *
  *     foo
  *       .catchError(..., test: (e) =&gt; e is ArgumentError)
  *       .catchError(..., test: (e) =&gt; e is NoSuchMethodError)
  *       .then((v) { ... });
  *
  * This method is equivalent to:
  *
  *     Future catchError(onError(AsyncError asyncError),
  *                       {bool test(Object error)}) {
  *       this.then((v) =&gt; v,  // Forward the value.
  *                 // But handle errors, if the [test] succeeds.
  *                 onError: (AsyncError e) {
  *                   if (test == null || test(e.error)) {
  *                     return onError(e);
  *                   }
  *                   throw e;
  *                 });
  *     }
  *
  */
 Future catchError(onError(AsyncError asyncError),
                   {bool test(Object error)});

 /**
  * Register a function to be called when this future completes.
  *
  * The [action] function is called when this future completes, whether it
  * does so with a value or with an error.
  *
  * This is the asynchronous equivalent of a "finally" block.
  *
  * The future returned by this call, `f`, will complete the same way
  * as this future unless an error occurs in the [action] call, or in
  * a [Future] returned by the [action] call. If the call to [action]
  * does not return a future, its return value is ignored.
  *
  * If the call to [action] throws, then `f` is completed with the
  * thrown error.
  *
  * If the call to [action] returns a [Future], `f2`, then completion of
  * `f` is delayed until `f2` completes. If `f2` completes with
  * an error, that will be the result of `f` too. The value of `f2` is always
  * ignored.
  *
  * This method is equivalent to:
  *
  *     Future&lt;T&gt; whenComplete(action()) {
  *       this.then((v) {
  *                   var f2 = action();
  *                   if (f2 is Future) return f2.then((_) =&gt; v);
  *                   return v
  *                 },
  *                 onError: (AsyncError e) {
  *                   var f2 = action();
  *                   if (f2 is Future) return f2.then((_) { throw e; });
  *                   throw e;
  *                 });
  *     }
  */
 Future&lt;T&gt; whenComplete(action());

 /**
  * Creates a [Stream] that sends [this]' completion value, data or error, to
  * its subscribers. The stream closes after the completion value.
  */
 Stream&lt;T&gt; asStream();
}
</pre>
</div>
<h3>Subclasses</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../substitute_future/SubstituteFuture.html">SubstituteFuture&lt;T&gt;</a></span></p>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="wait">
<button class="show-code">Code</button>
<a href="../dart_async/Future.html">Future</a>&lt;<a href="../dart_core/List.html">List</a>&gt; <strong>wait</strong>(<a href="../dart_core/Iterable.html">Iterable</a>&lt;<a href="../dart_async/Future.html">Future</a>&gt; futures) <a class="anchor-link" href="#wait"
              title="Permalink to Future&lt;T&gt;.wait">#</a></h4>
<div class="doc">
<p>Wait for all the given futures to complete and collect their values.</p>
<p>Returns a future which will complete once all the futures in a list are
complete. If any of the futures in the list completes with an error,
the resulting future also completes with an error. Otherwise the value
of the returned future will be a list of all the values that were produced.</p>
<pre class="source">
static Future&lt;List&gt; wait(Iterable&lt;Future&gt; futures) {
 return new _FutureImpl&lt;List&gt;.wait(futures);
}
</pre>
</div>
</div>
<div class="method"><h4 id="forEach">
<button class="show-code">Code</button>
<a href="../dart_async/Future.html">Future</a> <strong>forEach</strong>(<a href="../dart_core/Iterable.html">Iterable</a> input, <a href="../dart_async/Future.html">Future</a> f(element)) <a class="anchor-link" href="#forEach"
              title="Permalink to Future&lt;T&gt;.forEach">#</a></h4>
<div class="doc">
<p>Perform an async operation for each element of the iterable, in turn.</p>
<p>Runs 
<span class="param">f</span> for each element in 
<span class="param">input</span> in order, moving to the next element
only when the <a class="crossref" href="../dart_async/Future.html">Future</a> returned by 
<span class="param">f</span> completes. Returns a <a class="crossref" href="../dart_async/Future.html">Future</a> that
completes when all elements have been processed.</p>
<p>The return values of all <a class="crossref" href="../dart_async/Future.html">Future</a>s are discarded. Any errors will cause the
iteration to stop and will be piped through the returned <a class="crossref" href="../dart_async/Future.html">Future</a>.</p>
<pre class="source">
static Future forEach(Iterable input, Future f(element)) {
 _FutureImpl doneSignal = new _FutureImpl();
 Iterator iterator = input.iterator;
 void nextElement(_) {
   if (iterator.moveNext()) {
     f(iterator.current).then(nextElement, onError: doneSignal._setError);
   } else {
     doneSignal._setValue(null);
   }
 }
 nextElement(null);
 return doneSignal;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="Future.delayed">
<button class="show-code">Code</button>
factory <strong>Future.delayed</strong>(duration, [<a href="../dart_async/Future.html">T</a> computation()]) <a class="anchor-link" href="#Future.delayed"
              title="Permalink to Future&lt;T&gt;.Future.delayed">#</a></h4>
<div class="doc">
<p>Creates a future that completes after a delay.</p>
<p>The future will be completed after the given 
<span class="param">duration</span> has passed with
the result of calling 
<span class="param">computation</span>. If the duration is 0 or less, it
completes no sooner than in the next event-loop iteration.</p>
<p>If 
<span class="param">computation</span> is not given or <code>null</code> then it will behave as if

<span class="param">computation</span> was set to <code>() =&gt; null</code>. That is, it will complete with
<code>null</code>.</p>
<p>If calling 
<span class="param">computation</span> throws, the created future will complete with the
error.</p>
<p>See <a class="crossref" href="../dart_async/Completer.html">Completer</a>s, for futures with values that are computed asynchronously.</p>
<p><em>Deprecation note</em>: this method initially took an <code>int</code> as argument (the
milliseconds to wait). It is now a <code>Duration</code>.</p>
<pre class="source">
factory Future.delayed(var duration, [T computation()]) {
 // TODO(floitsch): no need to allocate a ThenFuture when the computation is
 // null.
 if (computation == null) computation = (() =&gt; null);
 _ThenFuture&lt;dynamic, T&gt; future =
     new _ThenFuture&lt;dynamic, T&gt;((_) =&gt; computation());
 new Timer(duration, () =&gt; future._sendValue(null));
 return future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="Future.immediate">
<button class="show-code">Code</button>
factory <strong>Future.immediate</strong>(<a href="../dart_async/Future.html">T</a> value) <a class="anchor-link" href="#Future.immediate"
              title="Permalink to Future&lt;T&gt;.Future.immediate">#</a></h4>
<div class="doc">
<p>A future whose value is available in the next event-loop iteration.</p>
<p>If 
<span class="param">value</span> is not a <a class="crossref" href="../dart_async/Future.html">Future</a>, using this constructor is equivalent
to <code>new Future.of(() =&gt; value)</code>.</p>
<p>See <a class="crossref" href="../dart_async/Completer.html">Completer</a> to create a Future and complete it later.</p>
<pre class="source">
factory Future.immediate(T value) =&gt; new _FutureImpl&lt;T&gt;.immediate(value);
</pre>
</div>
</div>
<div class="method"><h4 id="Future.immediateError">
<button class="show-code">Code</button>
factory <strong>Future.immediateError</strong>(error, [<a href="../dart_core/Object.html">Object</a> stackTrace]) <a class="anchor-link" href="#Future.immediateError"
              title="Permalink to Future&lt;T&gt;.Future.immediateError">#</a></h4>
<div class="doc">
<p>A future that completes with an error in the next event-loop iteration.</p>
<p>See <a class="crossref" href="../dart_async/Completer.html">Completer</a> to create a Future and complete it later.</p>
<pre class="source">
factory Future.immediateError(var error, [Object stackTrace]) {
 return new _FutureImpl&lt;T&gt;.immediateError(error, stackTrace);
}
</pre>
</div>
</div>
<div class="method"><h4 id="Future.of">
<button class="show-code">Code</button>
factory <strong>Future.of</strong>(function()) <a class="anchor-link" href="#Future.of"
              title="Permalink to Future&lt;T&gt;.Future.of">#</a></h4>
<div class="doc">
<p>Creates a future containing the result of calling 
<span class="param">function</span>.</p>
<p>The result of computing <code>function()</code> is either a returned value or
a throw.</p>
<p>If a value is returned, it becomes the result of the created future.</p>
<p>If calling 
<span class="param">function</span> throws, the created <a class="crossref" href="../dart_async/Future.html">Future</a> will be completed
with an async error containing the thrown value and a captured
stacktrace.</p>
<p>However, if the result of calling 
<span class="param">function</span> is already an asynchronous
result, we treat it specially.</p>
<p>If the returned value is itself a <a class="crossref" href="../dart_async/Future.html">Future</a>, completion of
the created future will wait until the returned future completes,
and will then complete with the same result.</p>
<p>If a thrown value is an <a class="crossref" href="../dart_async/AsyncError.html">AsyncError</a>, it is used directly as the result
of the created future.</p>
<pre class="source">
factory Future.of(function()) {
 try {
   var result = function();
   return new _FutureImpl&lt;T&gt;().._setOrChainValue(result);
 } catch (error, stackTrace) {
   return new _FutureImpl&lt;T&gt;.immediateError(error, stackTrace);
 }
}
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="asStream">
abstract <a href="../dart_async/Stream.html">Stream</a>&lt;<a href="../dart_async/Future.html">T</a>&gt; <strong>asStream</strong>() <a class="anchor-link" href="#asStream"
              title="Permalink to Future&lt;T&gt;.asStream">#</a></h4>
<div class="doc">
<p>Creates a <a class="crossref" href="../dart_async/Stream.html">Stream</a> that sends <code>this</code>' completion value, data or error, to
its subscribers. The stream closes after the completion value.</p>
</div>
</div>
<div class="method"><h4 id="catchError">
abstract <a href="../dart_async/Future.html">Future</a> <strong>catchError</strong>(onError(<a href="../dart_async/AsyncError.html">AsyncError</a> asyncError), {<a href="../dart_core/bool.html">bool</a> test(<a href="../dart_core/Object.html">Object</a> error)}) <a class="anchor-link" href="#catchError"
              title="Permalink to Future&lt;T&gt;.catchError">#</a></h4>
<div class="doc">
<p>Handles errors emitted by this <a class="crossref" href="../dart_async/Future.html">Future</a>.</p>
<p>Returns a new <a class="crossref" href="../dart_async/Future.html">Future</a> <code>f</code>.</p>
<p>When <code>this</code> completes with a value, the value is forwarded to <code>f</code>
unmodified. That is, <code>f</code> completes with the same value.</p>
<p>When <code>this</code> completes with an error, 
<span class="param">test</span> is called with the
error's value. If the invocation returns <code>true</code>, 
<span class="param">onError</span> is called with
the error wrapped in an <a class="crossref" href="../dart_async/AsyncError.html">AsyncError</a>. The result of 
<span class="param">onError</span> is handled
exactly the same as for <a class="crossref" href="../dart_async/Future.html#then">then</a>'s 
<span class="param">onError</span>.</p>
<p>If 
<span class="param">test</span> returns false, the exception is not handled by 
<span class="param">onError</span>, but is
thrown unmodified, thus forwarding it to <code>f</code>.</p>
<p>If 
<span class="param">test</span> is omitted, it defaults to a function that always returns true.</p>
<p>Example:</p>
<pre><code>foo
  .catchError(..., test: (e) =&gt; e is ArgumentError)
  .catchError(..., test: (e) =&gt; e is NoSuchMethodError)
  .then((v) { ... });
</code></pre>
<p>This method is equivalent to:</p>
<pre><code>Future catchError(onError(AsyncError asyncError),
                  {bool test(Object error)}) {
  this.then((v) =&gt; v,  // Forward the value.
            // But handle errors, if the [test] succeeds.
            onError: (AsyncError e) {
              if (test == null || test(e.error)) {
                return onError(e);
              }
              throw e;
            });
}
</code></pre>
</div>
</div>
<div class="method"><h4 id="then">
abstract <a href="../dart_async/Future.html">Future</a> <strong>then</strong>(onValue(<a href="../dart_async/Future.html">T</a> value), {onError(<a href="../dart_async/AsyncError.html">AsyncError</a> asyncError)}) <a class="anchor-link" href="#then"
              title="Permalink to Future&lt;T&gt;.then">#</a></h4>
<div class="doc">
<p>When this future completes with a value, then 
<span class="param">onValue</span> is called with this
value. If <code>this</code> future is already completed then the invocation of

<span class="param">onValue</span> is delayed until the next event-loop iteration.</p>
<p>Returns a new <a class="crossref" href="../dart_async/Future.html">Future</a> <code>f</code> which is completed with the result of
invoking 
<span class="param">onValue</span> (if <code>this</code> completes with a value) or 
<span class="param">onError</span> (if
<code>this</code> completes with an error).</p>
<p>If the invoked callback throws an exception, the returned future <code>f</code> is
completed with the error. If the value thrown is an <a class="crossref" href="../dart_async/AsyncError.html">AsyncError</a>, it is
used directly, as the error result. Otherwise it is wrapped in an
<a class="crossref" href="../dart_async/AsyncError.html">AsyncError</a> first.</p>
<p>If the invoked callback returns a <a class="crossref" href="../dart_async/Future.html">Future</a> <code>f2</code> then <code>f</code> and <code>f2</code> are
chained. That is, <code>f</code> is completed with the completion value of <code>f2</code>.</p>
<p>If 
<span class="param">onError</span> is not given, it is equivalent to <code>(e) { throw e; }</code>. That
is, it forwards the error to <code>f</code>.</p>
<p>In most cases, it is more readable to use <a class="crossref" href="../dart_async/Future.html#catchError">catchError</a> separately, possibly
with a <code>test</code> parameter, instead of handling both value and error in a
single <a class="crossref" href="../dart_async/Future.html#then">then</a> call.</p>
</div>
</div>
<div class="method"><h4 id="whenComplete">
abstract <a href="../dart_async/Future.html">Future</a>&lt;<a href="../dart_async/Future.html">T</a>&gt; <strong>whenComplete</strong>(action()) <a class="anchor-link" href="#whenComplete"
              title="Permalink to Future&lt;T&gt;.whenComplete">#</a></h4>
<div class="doc">
<p>Register a function to be called when this future completes.</p>
<p>The 
<span class="param">action</span> function is called when this future completes, whether it
does so with a value or with an error.</p>
<p>This is the asynchronous equivalent of a "finally" block.</p>
<p>The future returned by this call, <code>f</code>, will complete the same way
as this future unless an error occurs in the 
<span class="param">action</span> call, or in
a <a class="crossref" href="../dart_async/Future.html">Future</a> returned by the 
<span class="param">action</span> call. If the call to 
<span class="param">action</span>
does not return a future, its return value is ignored.</p>
<p>If the call to 
<span class="param">action</span> throws, then <code>f</code> is completed with the
thrown error.</p>
<p>If the call to 
<span class="param">action</span> returns a <a class="crossref" href="../dart_async/Future.html">Future</a>, <code>f2</code>, then completion of
<code>f</code> is delayed until <code>f2</code> completes. If <code>f2</code> completes with
an error, that will be the result of <code>f</code> too. The value of <code>f2</code> is always
ignored.</p>
<p>This method is equivalent to:</p>
<pre><code>Future&lt;T&gt; whenComplete(action()) {
  this.then((v) {
              var f2 = action();
              if (f2 is Future) return f2.then((_) =&gt; v);
              return v
            },
            onError: (AsyncError e) {
              var f2 = action();
              if (f2 is Future) return f2.then((_) { throw e; });
              throw e;
            });
}
</code></pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-02-26 14:50:19.833</div>
<div>        <p>Except as otherwise <a href="http://code.google.com/policies.html#restrictions">noted</a>, the content of this
        page is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution
        3.0 License</a>, and code samples are licensed under the
        <a href="http://code.google.com/google_bsd_license.html">BSD License</a>.</p>
        <p><a href="http://www.dartlang.org/tos.html">Terms of Service</a> |
        <a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a></p>
        </div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
