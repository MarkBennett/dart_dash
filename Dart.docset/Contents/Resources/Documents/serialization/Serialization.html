        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Serialization class / serialization Library / Dart API Reference</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        <link rel="stylesheet" type="text/css"
            href="../apidoc-styles.css" />
        
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(["_setAccount", "UA-26406144-9"]);
          _gaq.push(["_trackPageview"]);

          (function() {
            var ga = document.createElement("script");
            ga.type = "text/javascript"; ga.async = true;
            ga.src = ("https:" == document.location.protocol ?
              "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(ga, s);
          })();
        </script>
        
        </head>
        <body data-library="serialization" data-type="Serialization">
        <div class="page">
        <div class="header">
          <a href="http://dartlang.org" ref="external"><div class="logo"></div></a>
          <a href="../index.html">Dart API Reference</a>
         &rsaquo; <a href="../serialization.html">serialization</a> &rsaquo; <a href="../serialization/Serialization.html">Serialization</a>        <form action="http://www.dartlang.org/search.html" id="search-box">
          <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
          <input type="hidden" name="ie" value="UTF-8">
          <input type="hidden" name="hl" value="en">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </form>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../args.html">args</a></h2><h2><div class="icon-library"></div><a href="../dart_async.html">dart:async</a></h2><h2><div class="icon-library"></div><a href="../dart_chrome.html">dart:chrome</a></h2><h2><div class="icon-library"></div><a href="../dart_collection.html">dart:collection</a></h2><h2><div class="icon-library"></div><a href="../dart_core.html">dart:core</a></h2><h2><div class="icon-library"></div><a href="../dart_crypto.html">dart:crypto</a></h2><h2><div class="icon-library"></div><a href="../dart_html.html">dart:html</a></h2><h2><div class="icon-library"></div><a href="../dart_indexed_db.html">dart:indexed_db</a></h2><h2><div class="icon-library"></div><a href="../dart_io.html">dart:io</a></h2><h2><div class="icon-library"></div><a href="../dart_isolate.html">dart:isolate</a></h2><h2><div class="icon-library"></div><a href="../dart_json.html">dart:json</a></h2><h2><div class="icon-library"></div><a href="../dart_math.html">dart:math</a></h2><h2><div class="icon-library"></div><a href="../dart_mirrors.html">dart:mirrors</a></h2><h2><div class="icon-library"></div><a href="../dart_scalarlist.html">dart:scalarlist</a></h2><h2><div class="icon-library"></div><a href="../dart_svg.html">dart:svg</a></h2><h2><div class="icon-library"></div><a href="../dart_uri.html">dart:uri</a></h2><h2><div class="icon-library"></div><a href="../dart_utf.html">dart:utf</a></h2><h2><div class="icon-library"></div><a href="../dart_web_audio.html">dart:web_audio</a></h2><h2><div class="icon-library"></div><a href="../dart_web_sql.html">dart:web_sql</a></h2><h2><div class="icon-library"></div><a href="../fixnum.html">fixnum</a></h2><h2><div class="icon-library"></div><a href="../intl.html">intl</a></h2><h2><div class="icon-library"></div><a href="../logging.html">logging</a></h2><h2><div class="icon-library"></div><a href="../matcher.html">matcher</a></h2><h2><div class="icon-library"></div><a href="../meta.html">meta</a></h2><h2><div class="icon-library"></div><a href="../mock.html">mock</a></h2><h2><div class="icon-library"></div><a href="../scheduled_test.html">scheduled_test</a></h2><h2><div class="icon-library"></div><a href="../serialization.html">serialization</a></h2><ul class="icon">
<li><a href="../serialization/BasicRule.html"><div class="icon-class"></div>BasicRule</a></li>
<li><a href="../serialization/ClosureRule.html"><div class="icon-class"></div>ClosureRule</a></li>
<li><a href="../serialization/Constructor.html"><div class="icon-class"></div>Constructor</a></li>
<li><a href="../serialization/ConstructType.html"><div class="icon-interface"></div>ConstructType</a></li>
<li><a href="../serialization/CustomRule.html"><div class="icon-class"></div>CustomRule</a></li>
<li><a href="../serialization/DesignatedRuleForObject.html"><div class="icon-class"></div>DesignatedRuleForObject</a></li>
<li><a href="../serialization/Format.html"><div class="icon-class"></div>Format</a></li>
<li><a href="../serialization/GetStateType.html"><div class="icon-interface"></div>GetStateType</a></li>
<li><a href="../serialization/ListRule.html"><div class="icon-class"></div>ListRule</a></li>
<li><a href="../serialization/ListRuleEssential.html"><div class="icon-class"></div>ListRuleEssential</a></li>
<li><a href="../serialization/MapRule.html"><div class="icon-class"></div>MapRule</a></li>
<li><a href="../serialization/MirrorRule.html"><div class="icon-class"></div>MirrorRule</a></li>
<li><a href="../serialization/NamedObjectRule.html"><div class="icon-class"></div>NamedObjectRule</a></li>
<li><a href="../serialization/NonEssentialStateType.html"><div class="icon-interface"></div>NonEssentialStateType</a></li>
<li><a href="../serialization/PrimitiveRule.html"><div class="icon-class"></div>PrimitiveRule</a></li>
<li><a href="../serialization/Reader.html"><div class="icon-class"></div>Reader</a></li>
<li><a href="../serialization/ReaderOrWriter.html"><div class="icon-class"></div>ReaderOrWriter</a></li>
<li><a href="../serialization/Reference.html"><div class="icon-class"></div>Reference</a></li>
<li><div class="icon-class"></div><strong>Serialization</strong></li>
<li><a href="../serialization/SerializationRule.html"><div class="icon-class"></div>SerializationRule</a></li>
<li><a href="../serialization/SetWithFunction.html"><div class="icon-interface"></div>SetWithFunction</a></li>
<li><a href="../serialization/SimpleFlatFormat.html"><div class="icon-class"></div>SimpleFlatFormat</a></li>
<li><a href="../serialization/SimpleJsonFormat.html"><div class="icon-class"></div>SimpleJsonFormat</a></li>
<li><a href="../serialization/SimpleMapFormat.html"><div class="icon-class"></div>SimpleMapFormat</a></li>
<li><a href="../serialization/Trace.html"><div class="icon-class"></div>Trace</a></li>
<li><a href="../serialization/Writer.html"><div class="icon-class"></div>Writer</a></li>
<li><a href="../serialization/SerializationException.html"><div class="icon-exception"></div>SerializationException</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../unittest.html">unittest</a></h2></div>
<div class="content">
        <h2><strong>Serialization</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>This class defines a particular serialization scheme, in terms of
<a class="crossref" href="../serialization/SerializationRule.html">SerializationRule</a> instances, and supports reading and writing them.
See library comment for examples of usage.</p>
<pre class="source">
class Serialization {

 /**
  * The serialization is controlled by the list of Serialization rules. These
  * are most commonly added via [addRuleFor].
  */
 List _rules = [];

 /**
  * The serialization is controlled by the list of Serialization rules. These
  * are most commonly added via [addRuleFor].
  */
 List get rules =&gt; _rules;

 /**
  * When reading, we may need to resolve references to existing objects in
  * the system. The right action may not be to create a new instance of
  * something, but rather to find an existing instance and connect to it.
  * For example, if we have are serializing an Email message and it has a
  * link to the owning account, it may not be appropriate to try and serialize
  * the account. Instead we should just connect the de-serialized message
  * object to the account object that already exists there.
  */
 Map&lt;String, dynamic&gt; namedObjects = {};

 /**
  * When we write out data using this serialization, should we also write
  * out a description of the rules. This is on by default unless using
  * CustomRule subclasses, in which case it requires additional setup and
  * is off by default.
  */
 bool _selfDescribing;

 /**
  * When we write out data using this serialization, should we also write
  * out a description of the rules. This is on by default unless using
  * CustomRule subclasses, in which case it requires additional setup and
  * is off by default.
  */
 bool get selfDescribing {
   // TODO(alanknight): Should this be moved to the format?
   // TODO(alanknight): Allow self-describing in the presence of CustomRule.
   if (_selfDescribing != null) return _selfDescribing;
   return !_rules.any((x) =&gt; x is CustomRule);
 }

 /**
  * When we write out data using this serialization, should we also write
  * out a description of the rules. This is on by default unless using
  * CustomRule subclasses, in which case it requires additional setup and
  * is off by default.
  */
 set selfDescribing(x) =&gt; _selfDescribing = x;

 /**
  * Creates a new serialization with a default set of rules for primitives
  * and lists.
  */
 Serialization() {
   addDefaultRules();
 }

 /**
  * Creates a new serialization with no default rules at all. The most common
  * use for this is if we are reading self-describing serialized data and
  * will populate the rules from that data.
  */
 Serialization.blank() { }

 /**
  * Create a [BasicRule] rule for the type of
  * [instanceOfType]. Optionally
  * allows specifying a [constructor] name, the list of [constructorFields],
  * and the list of [fields] not used in the constructor. Returns the new
  * rule. Note that [BasicRule] uses reflection, and so will not work with the
  * current state of dartj2s. If you need to run there, consider using
  * [CustomRule] instead.
  *
  * If the optional parameters aren't specified, the default constructor will
  * be used, and the list of fields will be computed. Alternatively, you can
  * omit [fields] and provide [excludeFields], which will then compute the
  * list of fields specifically excluding those listed.
  *
  * The fields can be actual public fields, but can also be getter/setter
  * pairs or getters whose value is provided in the constructor. For the
  * [constructorFields] they can also be arbitrary objects. Anything that is
  * not a String will be treated as a constant value to be used in any
  * construction of these objects.
  *
  * If the list of fields is computed, fields from the superclass will be
  * included. However, each subclass needs its own rule, since the constructors
  * are not inherited, and so may need to be specified separately for each
  * subclass.
  */
 // TODO(alanknight): Take a type rather than an instance. Issue 6282 and 6433.
 BasicRule addRuleFor(
     instanceOfType,
     {String constructor,
       List constructorFields,
       List&lt;String&gt; fields,
       List&lt;String&gt; excludeFields}) {

   var rule;
   rule = new BasicRule(
       turnInstanceIntoSomethingWeCanUse(
           instanceOfType),
       constructor, constructorFields, fields, excludeFields);
   addRule(rule);
   return rule;
 }

 /** Set up the default rules, for lists and primitives. */
 void addDefaultRules() {
   addRule(new PrimitiveRule());
   addRule(new ListRule());
   // Both these rules apply to lists, so unless otherwise indicated,
   // it will always find the first one.
   addRule(new ListRuleEssential());
   addRule(new MapRule());
 }

 /**
  * Add a new SerializationRule [rule]. The addRuleFor method will probably
  * handle most simple cases, but for adding an arbitrary rule, including
  * a SerializationRule subclass which you have created, you can use this
  * method.
  */
 void addRule(SerializationRule rule) {
   rule.number = _rules.length;
   _rules.add(rule);
 }

 /**
  * This writes out an object graph rooted at [object] and returns the result.
  * The [format] parameter determines the form of the result. The default
  * format returns a String in [json] format.
  */
 write(Object object, [Format format]) {
   return newWriter(format).write(object);
 }

 /**
  * Return a new [Writer] object for this serialization. This is useful if you
  * want to do something more complex with the writer than just returning
  * the final result.
  */
 Writer newWriter([Format format]) =&gt;
     new Writer(this, format);

 /**
  * Read the serialized data from [input] and return the root object
  * from the result. The [input] can be of any type that the [Format]
  * reads/writes, but normally will be a [List], [Map], or a simple type.
  * If there are objects that need to be resolved
  * in the current context, they should be provided in [externals] as a
  * Map from names to values. In particular, in the current implementation
  * any class mirrors needed should be provided in [externals] using the
  * class name as a key. In addition to the [externals] map provided here,
  * values will be looked up in the [namedObjects] map.
  */
 read(input, [Map externals = const {}]) {
   return newReader().read(input, externals);
 }

 /**
  * Return a new [Reader] object for this serialization. This is useful if
  * you want to do something more complex with the reader than just returning
  * the final result.
  */
 Reader newReader([Format format]) =&gt; new Reader(this, format);

 /**
  * Return the list of SerializationRule that apply to [object]. For
  * internal use, but public because it's used in testing.
  */
 Iterable&lt;SerializationRule&gt; rulesFor(object, Writer w) {
   // This has a couple of edge cases.
   // 1) The owning object may have indicated we should use a different
   // rule than the default.
   // 2) We may not have a rule, in which case we lazily create a BasicRule.
   // 3) Rules are allowed to say mustBePrimary, meaning that they can be used
   // iff no other rule was chosen first.
   // TODO(alanknight): Can the mustBePrimary mechanism be removed or changed.
   // It adds an order dependency to the rules, and is messy. Reconsider in the
   // light of a more general mechanism for multiple rules per object.
   // TODO(alanknight): Finding which rules apply seems likely to be a
   // bottleneck, particularly with the current reflective implementation.
   // Consider how to improve it. e.g. cache the list of rules by class. But
   // be careful of issues like rules which have arbitrary predicates. Or
   // consider having the arbitrary predicates be secondary to an initial
   // class-based lookup mechanism.
   var target, candidateRules;
   if (object is DesignatedRuleForObject) {
     target = object.target;
     candidateRules = object.possibleRules(_rules);
   } else {
     target = object;
     candidateRules = _rules;
   }
   Iterable applicable = candidateRules.where(
       (each) =&gt; each.appliesTo(target, w));

   if (applicable.isEmpty) {
     return [addRuleFor(target)];
   }

   if (applicable.length == 1) return applicable;
   var first = applicable.first;
   var finalRules = applicable.where(
       (x) =&gt; !x.mustBePrimary || (x == first));

   if (finalRules.isEmpty) throw new SerializationException(
       'No valid rule found for object $object');
   return finalRules;
 }

 /**
  * Create a Serialization for serializing SerializationRules. This is used
  * to save the rules in a self-describing format along with the data.
  * If there are new rule classes created, they will need to be described
  * here.
  */
 Serialization ruleSerialization() {
   // TODO(alanknight): There's an extensibility issue here with new rules.
   // TODO(alanknight): How to handle rules with closures? They have to
   // exist on the other side, but we might be able to hook them up by name,
   // or we might just be able to validate that they're correctly set up
   // on the other side.

   // Make some bogus rule instances so we have something to feed rule creation
   // and get their types. If only we had class literals implemented...
  var basicRule = new BasicRule(reflect(null).type, '', [], [], []);

   var meta = new Serialization()
     ..selfDescribing = false
     ..addRuleFor(new ListRule())
     ..addRuleFor(new MapRule())
     ..addRuleFor(new PrimitiveRule())
     ..addRuleFor(new ListRuleEssential())
     ..addRuleFor(basicRule,
         constructorFields: ['type',
           'constructorName',
           'constructorFields', 'regularFields', []],
         fields: [])
     ..addRule(new NamedObjectRule())
     ..addRule(new MirrorRule());
   meta.namedObjects = namedObjects;
   return meta;
 }

 /** Return true if our [namedObjects] collection has an entry for [object].*/
 bool _hasNameFor(object) {
   var sentinel = const _Sentinel();
   return _nameFor(object, () =&gt; sentinel) != sentinel;
 }

 /**
  * Return the name we have for [object] in our [namedObjects] collection or
  * the result of evaluating [ifAbsent] if there is no entry.
  */
 _nameFor(object, [ifAbsent]) {
   for (var key in namedObjects.keys) {
     if (identical(namedObjects[key], object)) return key;
   }
   return ifAbsent == null ? null : ifAbsent();
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="Serialization">
<button class="show-code">Code</button>
new <strong>Serialization</strong>() <a class="anchor-link" href="#Serialization"
              title="Permalink to Serialization.Serialization">#</a></h4>
<div class="doc">
<p>Creates a new serialization with a default set of rules for primitives
and lists.</p>
<pre class="source">
Serialization() {
 addDefaultRules();
}
</pre>
</div>
</div>
<div class="method"><h4 id="Serialization.blank">
<button class="show-code">Code</button>
new <strong>Serialization.blank</strong>() <a class="anchor-link" href="#Serialization.blank"
              title="Permalink to Serialization.Serialization.blank">#</a></h4>
<div class="doc">
<p>Creates a new serialization with no default rules at all. The most common
use for this is if we are reading self-describing serialized data and
will populate the rules from that data.</p>
<pre class="source">
Serialization.blank() { }
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="namedObjects">
<button class="show-code">Code</button>
<a href="../dart_core/Map.html">Map</a>&lt;<a href="../dart_core/String.html">String</a>, dynamic&gt;         <strong>namedObjects</strong> <a class="anchor-link"
            href="#namedObjects"
            title="Permalink to Serialization.namedObjects">#</a>
        </h4>
        <div class="doc">
<pre class="source">
namedObjects = {}
</pre>
</div>
</div>
<div class="field"><h4 id="rules">
<button class="show-code">Code</button>
final <a href="../dart_core/List.html">List</a>         <strong>rules</strong> <a class="anchor-link"
            href="#rules"
            title="Permalink to Serialization.rules">#</a>
        </h4>
        <div class="doc">
<p>The serialization is controlled by the list of Serialization rules. These
are most commonly added via <a class="crossref" href="../serialization/Serialization.html#addRuleFor">addRuleFor</a>.</p>
<pre class="source">
List get rules =&gt; _rules;
</pre>
</div>
</div>
<div class="method"><h4 id="selfDescribing">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>get selfDescribing</strong> <a class="anchor-link" href="#selfDescribing"
              title="Permalink to Serialization.get selfDescribing">#</a></h4>
<div class="doc">
<p>When we write out data using this serialization, should we also write
out a description of the rules. This is on by default unless using
CustomRule subclasses, in which case it requires additional setup and
is off by default.</p>
<pre class="source">
bool get selfDescribing {
 // TODO(alanknight): Should this be moved to the format?
 // TODO(alanknight): Allow self-describing in the presence of CustomRule.
 if (_selfDescribing != null) return _selfDescribing;
 return !_rules.any((x) =&gt; x is CustomRule);
}
</pre>
</div>
</div>
<div class="method"><h4 id="selfDescribing=">
<button class="show-code">Code</button>
<strong>set selfDescribing</strong>(x) <a class="anchor-link" href="#selfDescribing="
              title="Permalink to Serialization.set selfDescribing">#</a></h4>
<div class="doc">
<p>When we write out data using this serialization, should we also write
out a description of the rules. This is on by default unless using
CustomRule subclasses, in which case it requires additional setup and
is off by default.</p>
<pre class="source">
set selfDescribing(x) =&gt; _selfDescribing = x;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="addDefaultRules">
<button class="show-code">Code</button>
void <strong>addDefaultRules</strong>() <a class="anchor-link" href="#addDefaultRules"
              title="Permalink to Serialization.addDefaultRules">#</a></h4>
<div class="doc">
<p>Set up the default rules, for lists and primitives. </p>
<pre class="source">
void addDefaultRules() {
 addRule(new PrimitiveRule());
 addRule(new ListRule());
 // Both these rules apply to lists, so unless otherwise indicated,
 // it will always find the first one.
 addRule(new ListRuleEssential());
 addRule(new MapRule());
}
</pre>
</div>
</div>
<div class="method"><h4 id="addRule">
<button class="show-code">Code</button>
void <strong>addRule</strong>(<a href="../serialization/SerializationRule.html">SerializationRule</a> rule) <a class="anchor-link" href="#addRule"
              title="Permalink to Serialization.addRule">#</a></h4>
<div class="doc">
<p>Add a new SerializationRule 
<span class="param">rule</span>. The addRuleFor method will probably
handle most simple cases, but for adding an arbitrary rule, including
a SerializationRule subclass which you have created, you can use this
method.</p>
<pre class="source">
void addRule(SerializationRule rule) {
 rule.number = _rules.length;
 _rules.add(rule);
}
</pre>
</div>
</div>
<div class="method"><h4 id="addRuleFor">
<button class="show-code">Code</button>
<a href="../serialization/BasicRule.html">BasicRule</a> <strong>addRuleFor</strong>(instanceOfType, {<a href="../dart_core/String.html">String</a> constructor, <a href="../dart_core/List.html">List</a> constructorFields, <a href="../dart_core/List.html">List</a>&lt;<a href="../dart_core/String.html">String</a>&gt; fields, <a href="../dart_core/List.html">List</a>&lt;<a href="../dart_core/String.html">String</a>&gt; excludeFields}) <a class="anchor-link" href="#addRuleFor"
              title="Permalink to Serialization.addRuleFor">#</a></h4>
<div class="doc">
<p>Create a <a class="crossref" href="../serialization/BasicRule.html">BasicRule</a> rule for the type of

<span class="param">instanceOfType</span>. Optionally
allows specifying a 
<span class="param">constructor</span> name, the list of 
<span class="param">constructorFields</span>,
and the list of 
<span class="param">fields</span> not used in the constructor. Returns the new
rule. Note that <a class="crossref" href="../serialization/BasicRule.html">BasicRule</a> uses reflection, and so will not work with the
current state of dartj2s. If you need to run there, consider using
<a class="crossref" href="../serialization/CustomRule.html">CustomRule</a> instead.</p>
<p>If the optional parameters aren't specified, the default constructor will
be used, and the list of fields will be computed. Alternatively, you can
omit 
<span class="param">fields</span> and provide 
<span class="param">excludeFields</span>, which will then compute the
list of fields specifically excluding those listed.</p>
<p>The fields can be actual public fields, but can also be getter/setter
pairs or getters whose value is provided in the constructor. For the

<span class="param">constructorFields</span> they can also be arbitrary objects. Anything that is
not a String will be treated as a constant value to be used in any
construction of these objects.</p>
<p>If the list of fields is computed, fields from the superclass will be
included. However, each subclass needs its own rule, since the constructors
are not inherited, and so may need to be specified separately for each
subclass.</p>
<pre class="source">
BasicRule addRuleFor(
   instanceOfType,
   {String constructor,
     List constructorFields,
     List&lt;String&gt; fields,
     List&lt;String&gt; excludeFields}) {

 var rule;
 rule = new BasicRule(
     turnInstanceIntoSomethingWeCanUse(
         instanceOfType),
     constructor, constructorFields, fields, excludeFields);
 addRule(rule);
 return rule;
}
</pre>
</div>
</div>
<div class="method"><h4 id="newReader">
<button class="show-code">Code</button>
<a href="../serialization/Reader.html">Reader</a> <strong>newReader</strong>([<a href="../serialization/Format.html">Format</a> format]) <a class="anchor-link" href="#newReader"
              title="Permalink to Serialization.newReader">#</a></h4>
<div class="doc">
<p>Return a new <a class="crossref" href="../serialization/Reader.html">Reader</a> object for this serialization. This is useful if
you want to do something more complex with the reader than just returning
the final result.</p>
<pre class="source">
Reader newReader([Format format]) =&gt; new Reader(this, format);
</pre>
</div>
</div>
<div class="method"><h4 id="newWriter">
<button class="show-code">Code</button>
<a href="../serialization/Writer.html">Writer</a> <strong>newWriter</strong>([<a href="../serialization/Format.html">Format</a> format]) <a class="anchor-link" href="#newWriter"
              title="Permalink to Serialization.newWriter">#</a></h4>
<div class="doc">
<p>Return a new <a class="crossref" href="../serialization/Writer.html">Writer</a> object for this serialization. This is useful if you
want to do something more complex with the writer than just returning
the final result.</p>
<pre class="source">
Writer newWriter([Format format]) =&gt;
   new Writer(this, format);
</pre>
</div>
</div>
<div class="method"><h4 id="read">
<button class="show-code">Code</button>
<strong>read</strong>(input, [<a href="../dart_core/Map.html">Map</a> externals = const{}]) <a class="anchor-link" href="#read"
              title="Permalink to Serialization.read">#</a></h4>
<div class="doc">
<p>Read the serialized data from 
<span class="param">input</span> and return the root object
from the result. The 
<span class="param">input</span> can be of any type that the <a class="crossref" href="../serialization/Format.html">Format</a>
reads/writes, but normally will be a <code>List</code>, <code>Map</code>, or a simple type.
If there are objects that need to be resolved
in the current context, they should be provided in 
<span class="param">externals</span> as a
Map from names to values. In particular, in the current implementation
any class mirrors needed should be provided in 
<span class="param">externals</span> using the
class name as a key. In addition to the 
<span class="param">externals</span> map provided here,
values will be looked up in the <a class="crossref" href="../serialization/Serialization.html#namedObjects">namedObjects</a> map.</p>
<pre class="source">
read(input, [Map externals = const {}]) {
 return newReader().read(input, externals);
}
</pre>
</div>
</div>
<div class="method"><h4 id="ruleSerialization">
<button class="show-code">Code</button>
<a href="../serialization/Serialization.html">Serialization</a> <strong>ruleSerialization</strong>() <a class="anchor-link" href="#ruleSerialization"
              title="Permalink to Serialization.ruleSerialization">#</a></h4>
<div class="doc">
<p>Create a Serialization for serializing SerializationRules. This is used
to save the rules in a self-describing format along with the data.
If there are new rule classes created, they will need to be described
here.</p>
<pre class="source">
Serialization ruleSerialization() {
 // TODO(alanknight): There's an extensibility issue here with new rules.
 // TODO(alanknight): How to handle rules with closures? They have to
 // exist on the other side, but we might be able to hook them up by name,
 // or we might just be able to validate that they're correctly set up
 // on the other side.

 // Make some bogus rule instances so we have something to feed rule creation
 // and get their types. If only we had class literals implemented...
var basicRule = new BasicRule(reflect(null).type, '', [], [], []);

 var meta = new Serialization()
   ..selfDescribing = false
   ..addRuleFor(new ListRule())
   ..addRuleFor(new MapRule())
   ..addRuleFor(new PrimitiveRule())
   ..addRuleFor(new ListRuleEssential())
   ..addRuleFor(basicRule,
       constructorFields: ['type',
         'constructorName',
         'constructorFields', 'regularFields', []],
       fields: [])
   ..addRule(new NamedObjectRule())
   ..addRule(new MirrorRule());
 meta.namedObjects = namedObjects;
 return meta;
}
</pre>
</div>
</div>
<div class="method"><h4 id="rulesFor">
<button class="show-code">Code</button>
<a href="../dart_core/Iterable.html">Iterable</a>&lt;<a href="../serialization/SerializationRule.html">SerializationRule</a>&gt; <strong>rulesFor</strong>(object, <a href="../serialization/Writer.html">Writer</a> w) <a class="anchor-link" href="#rulesFor"
              title="Permalink to Serialization.rulesFor">#</a></h4>
<div class="doc">
<p>Return the list of SerializationRule that apply to 
<span class="param">object</span>. For
internal use, but public because it's used in testing.</p>
<pre class="source">
Iterable&lt;SerializationRule&gt; rulesFor(object, Writer w) {
 // This has a couple of edge cases.
 // 1) The owning object may have indicated we should use a different
 // rule than the default.
 // 2) We may not have a rule, in which case we lazily create a BasicRule.
 // 3) Rules are allowed to say mustBePrimary, meaning that they can be used
 // iff no other rule was chosen first.
 // TODO(alanknight): Can the mustBePrimary mechanism be removed or changed.
 // It adds an order dependency to the rules, and is messy. Reconsider in the
 // light of a more general mechanism for multiple rules per object.
 // TODO(alanknight): Finding which rules apply seems likely to be a
 // bottleneck, particularly with the current reflective implementation.
 // Consider how to improve it. e.g. cache the list of rules by class. But
 // be careful of issues like rules which have arbitrary predicates. Or
 // consider having the arbitrary predicates be secondary to an initial
 // class-based lookup mechanism.
 var target, candidateRules;
 if (object is DesignatedRuleForObject) {
   target = object.target;
   candidateRules = object.possibleRules(_rules);
 } else {
   target = object;
   candidateRules = _rules;
 }
 Iterable applicable = candidateRules.where(
     (each) =&gt; each.appliesTo(target, w));

 if (applicable.isEmpty) {
   return [addRuleFor(target)];
 }

 if (applicable.length == 1) return applicable;
 var first = applicable.first;
 var finalRules = applicable.where(
     (x) =&gt; !x.mustBePrimary || (x == first));

 if (finalRules.isEmpty) throw new SerializationException(
     'No valid rule found for object $object');
 return finalRules;
}
</pre>
</div>
</div>
<div class="method"><h4 id="write">
<button class="show-code">Code</button>
<strong>write</strong>(<a href="../dart_core/Object.html">Object</a> object, [<a href="../serialization/Format.html">Format</a> format]) <a class="anchor-link" href="#write"
              title="Permalink to Serialization.write">#</a></h4>
<div class="doc">
<p>This writes out an object graph rooted at 
<span class="param">object</span> and returns the result.
The 
<span class="param">format</span> parameter determines the form of the result. The default
format returns a String in <code>json</code> format.</p>
<pre class="source">
write(Object object, [Format format]) {
 return newWriter(format).write(object);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-02-26 14:53:07.333</div>
<div>        <p>Except as otherwise <a href="http://code.google.com/policies.html#restrictions">noted</a>, the content of this
        page is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution
        3.0 License</a>, and code samples are licensed under the
        <a href="http://code.google.com/google_bsd_license.html">BSD License</a>.</p>
        <p><a href="http://www.dartlang.org/tos.html">Terms of Service</a> |
        <a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a></p>
        </div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
